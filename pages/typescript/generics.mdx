## TypeScript: Дженерики – Гибкость и Типобезопасность


![Иллюстрация к уроку](/lessons/generics.png)
Дженерики (обобщения) – это мощный инструмент в TypeScript, позволяющий создавать компоненты, которые могут работать с *любым* типом данных, сохраняя при этом типобезопасность. Они позволяют писать гибкий и переиспользуемый код, избегая дублирования и потерь информации о типах.

### Проблема: Повторение и Потеря Типов

Рассмотрим простую функцию `identity`, которая возвращает переданное ей значение. Без дженериков нам пришлось бы либо дублировать код, либо терять информацию о типе:

```typescript
function identityNumber(arg: number): number {
  return arg;
}

function identityString(arg: string): string {
  return arg;
}

// Проблема 1: Дублирование кода для каждого типа
console.log(identityNumber(42).toFixed(0)); // OK: компилятор знает, что это number
// console.log(identityNumber('hello').toUpperCase()); // Ошибка компиляции

function identityAny(arg: any): any {
  return arg;
}

// Проблема 2: Потеря типа — компилятор не знает, какой тип вернется
let strVal = identityAny('TypeScript');
strVal.toUpperCase(); // OK, но компилятор не знает, что это string.
                      // Если бы был identityAny(42), .toUpperCase() было бы ошибкой рантайма.
// strVal.toFixed(0); // Ошибка только в рантайме, если strVal был бы строкой
```

### Решение: Базовые Дженерики

Дженерики позволяют объявить параметр типа, который будет использоваться внутри функции, класса или интерфейса. Этот параметр типа определяется во время использования (вывода), а не во время объявления.

```typescript
function identity<T>(arg: T): T {
  return arg;
}

// Компилятор выводит тип T на основе переданного аргумента
let outputNumber = identity(100);       // outputNumber имеет тип number
console.log(outputNumber.toFixed(2));   // Типобезопасно: OK

let outputString = identity("Generics"); // outputString имеет тип string
console.log(outputString.toUpperCase()); // Типобезопасно: OK

// Можно явно указать параметр типа, хотя чаще это не требуется
let outputBoolean = identity<boolean>(true); // outputBoolean имеет тип boolean
```

Здесь `T` — это параметр типа (type parameter). Это соглашение, что для обозначения обобщенных типов используются заглавные буквы, как `T` (Type), `K` (Key), `V` (Value), `E` (Element).

### Продвинутые Техники с Дженериками

#### 1. Несколько Параметров Типа

Функции и классы могут иметь несколько независимых параметров типа:

```typescript
function mergeObjects<T, U>(obj1: T, obj2: U): T & U {
  return { ...obj1, ...obj2 };
}

let merged = mergeObjects({ name: "Alice" }, { age: 30 });
// merged имеет тип { name: string; } & { age: number; }
console.log(merged.name); // Alice
console.log(merged.age);  // 30
// console.log(merged.salary); // Ошибка компиляции: Property 'salary' does not exist on type 'T & U'.
```

#### 2. Ограничения Дженериков (Constraints)

Иногда нам нужно работать с обобщенным типом, который обладает определенными свойствами. Для этого используются ограничения с помощью ключевого слова `extends`:

```typescript
interface Lengthwise {
  length: number;
}

// T должен быть типом, который имеет свойство 'length' типа number
function getLength<T extends Lengthwise>(arg: T): number {
  return arg.length;
}

console.log(getLength("hello world"));     // 11 (string имеет свойство length)
console.log(getLength([1, 2, 3, 4]));   // 4 (array имеет свойство length)
console.log(getLength({ length: 10 })); // 10
// getLength(42); // Ошибка компиляции: Argument of type 'number' is not assignable to parameter of type 'Lengthwise'.
```

#### 3. Использование Параметров Типа в Ограничениях

Можно использовать один параметр типа для ограничения другого, часто с `keyof`:

```typescript
// K должен быть ключом (именем свойства) типа T
function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key];
}

const user = { id: 1, name: "Bob", email: "bob@example.com" };

let userName = getProperty(user, "name");  // userName имеет тип string
let userId = getProperty(user, "id");      // userId имеет тип number
// let userAddress = getProperty(user, "address"); // Ошибка компиляции: Argument of type '"address"' is not assignable to parameter of type '"id" | "name" | "email"'.
```

Здесь `K extends keyof T` гарантирует, что `key` является одним из ключей объекта `obj`. `T[K]` затем правильно выводит тип значения свойства.

#### 4. Дженерики в Классах

Классы также могут быть обобщенными, позволяя создавать типобезопасные коллекции или обёртки для любого типа:

```typescript
class Container<T> {
  private value: T;
  constructor(value: T) {
    this.value = value;
  }
  getValue(): T {
    return this.value;
  }
}

let numberContainer = new Container(123); // numberContainer имеет тип Container<number>
console.log(numberContainer.getValue().toFixed(0)); // OK

let stringContainer = new Container("text"); // stringContainer имеет тип Container<string>
console.log(stringContainer.getValue().toUpperCase()); // OK
// console.log(stringContainer.getValue().toFixed(0)); // Ошибка компиляции
```

#### 5. Дженерики в Интерфейсах и Псевдонимах Типов (Type Aliases)

Дженерики могут использоваться для создания гибких типов данных:

```typescript
interface ApiResponse<T> {
  status: number;
  data: T;
  message?: string;
}

interface User {
  id: number;
  name: string;
}

const userResponse: ApiResponse<User> = {
  status: 200,
  data: { id: 1, name: "Alice" }
};
console.log(userResponse.data.name); // Alice, тип data корректно выведен как User
// console.log(userResponse.data.email); // Ошибка компиляции

type Result<T, E> = { success: true; value: T } | { success: false; error: E };

function processData<T>(input: T): Result<T, string> {
  if (Math.random() > 0.5) {
    return { success: true, value: input };
  } else {
    return { success: false, error: "Processing failed" };
  }
}

const res = processData(42);
if (res.success) {
  // TypeScript сужает тип res.value до number
  console.log(res.value.toFixed(2));
} else {
  // TypeScript сужает тип res.error до string
  console.log(res.error.toUpperCase());
}
```

### Практика и Выводы

Дженерики — это фундаментальный паттерн для создания типобезопасного, гибкого и повторно используемого кода в TypeScript. Они позволяют вам писать код, который работает с множеством различных типов, не жертвуя при этом строгой проверкой типов. Использование дженериков особенно ценно при разработке библиотек, фреймворков и API, где необходимо поддерживать различные варианты использования данных, обеспечивая при этом предсказуемое поведение и надёжность.