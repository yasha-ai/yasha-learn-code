## TypeScript: Декораторы – Метапрограммирование с декларативным подходом

![Иллюстрация к уроку](/lessons/typescript-decorators.png)


Декораторы в TypeScript – это специальные функции, которые могут быть применены к классам, методам, аксессорам, свойствам или параметрам во время объявления. Они предоставляют мощный способ для метапрограммирования, позволяя модифицировать или расширять функциональность этих объявлений декларативным образом, без изменения их внутренней реализации. Это очень полезно для реализации аспектов, таких как логирование, валидация, аутентификация, внедрение зависимостей (DI) и многое другое.

### Проблема без Декораторов: Повторяющийся Код

Представьте, что нам нужно измерить время выполнения нескольких методов в классе. Без декораторов, мы могли бы прийти к такому решению:

```typescript
class ProductService {
    getProductById(id: number): { id: number; name: string } | undefined {
        console.time('getProductById');
        // Имитация асинхронной операции
        const product = { id, name: `Product ${id}` };
        console.timeEnd('getProductById');
        return product;
    }

    createProduct(name: string): { id: number; name: string } {
        console.time('createProduct');
        const newId = Math.floor(Math.random() * 1000);
        const product = { id: newId, name };
        console.timeEnd('createProduct');
        return product;
    }
}

const service = new ProductService();
service.getProductById(1);
service.createProduct("New Widget");
```

Этот подход приводит к дублированию кода, снижает читаемость и усложняет поддержку, если логика логирования изменится или потребуется добавить её в новые методы.

### Решение с TypeScript: Легаси Декораторы (`experimentalDecorators`)

До TypeScript 5.0, декораторы были экспериментальной возможностью, которая включалась флагом компилятора `--experimentalDecorators`. Большинство существующих библиотек (например, Angular, TypeORM) используют именно этот стандарт.

Давайте преобразуем наш пример с помощью декоратора метода.

#### Декораторы Методов

Декоратор метода принимает три аргумента:
1.  `target`: Прототип класса для статических членов или конструктор класса для членов экземпляра.
2.  `propertyKey`: Имя члена.
3.  `descriptor`: Дескриптор свойства (из `Object.getOwnPropertyDescriptor`).

```typescript
// В tsconfig.json: "experimentalDecorators": true, "emitDecoratorMetadata": true

function logExecutionTime(target: Object, propertyKey: string | symbol, descriptor: PropertyDescriptor) {
    const originalMethod = descriptor.value; // Сохраняем оригинальную реализацию метода

    descriptor.value = function (...args: any[]) {
        const start = performance.now();
        const result = originalMethod.apply(this, args); // Вызываем оригинальный метод
        const end = performance.now();
        console.log(`[${String(propertyKey)}] Выполнено за ${end - start} мс.`);
        return result;
    };

    // Возвращаем модифицированный дескриптор свойства
    return descriptor;
}

class ProductServiceDecorated {
    @logExecutionTime
    getProductById(id: number): { id: number; name: string } | undefined {
        // ... имитация операции
        return { id, name: `Product ${id}` };
    }

    @logExecutionTime
    createProduct(name: string): { id: number; name: string } {
        // ... имитация операции
        const newId = Math.floor(Math.random() * 1000);
        return { id: newId, name };
    }
}

const decoratedService = new ProductServiceDecorated();
decoratedService.getProductById(1); // [getProductById] Выполнено за X мс.
decoratedService.createProduct("Super Widget"); // [createProduct] Выполнено за Y мс.
```
Теперь логика логирования декларативно применяется ко всем необходимым методам, избегая дублирования.

#### Декораторы Классов

Декоратор класса принимает один аргумент: конструктор класса.

```typescript
function sealed<T extends new (...args: any[]) => {}>(constructor: T) {
    Object.seal(constructor); // Запрещаем добавление/удаление свойств у конструктора
    Object.seal(constructor.prototype); // Запрещаем добавление/удаление свойств у прототипа
    console.log(`Класс ${constructor.name} и его прототип запечатаны.`);
}

@sealed
class UserProfile {
    constructor(public name: string, public email: string) {}

    displayInfo() {
        console.log(`Имя: ${this.name}, Email: ${this.email}`);
    }
}

// const user = new UserProfile("Иван", "ivan@example.com");
// Object.isSealed(UserProfile);       // true
// Object.isSealed(UserProfile.prototype); // true

// Попытка добавить свойство после @sealed приведет к ошибке в строгом режиме
// Object.defineProperty(UserProfile.prototype, 'newMethod', { value: () => {} });
```

#### Декораторы Свойств

Декоратор свойства принимает два аргумента:
1.  `target`: Прототип класса.
2.  `propertyKey`: Имя свойства.

```typescript
function defaultValue<T>(value: T) {
    return function (target: Object, propertyKey: string | symbol) {
        let _value: T = value; // Приватное хранилище для значения по умолчанию

        // Переопределяем геттер и сеттер свойства
        Object.defineProperty(target, propertyKey, {
            get: function() {
                // Если свойство не было установлено явно, возвращаем значение по умолчанию
                return this[`__${String(propertyKey)}_actualValue`] !== undefined
                       ? this[`__${String(propertyKey)}_actualValue`]
                       : _value;
            },
            set: function(val: T) {
                // Сохраняем явно установленное значение
                this[`__${String(propertyKey)}_actualValue`] = val;
            },
            enumerable: true,
            configurable: true,
        });
    };
}

class Settings {
    @defaultValue(true)
    isDebugMode!: boolean;

    @defaultValue("default-user")
    username!: string;
}

const appSettings = new Settings();
console.log(appSettings.isDebugMode); // true
console.log(appSettings.username);   // "default-user"

appSettings.isDebugMode = false;
console.log(appSettings.isDebugMode); // false
```

#### Декораторы Параметров

Декоратор параметра принимает три аргумента:
1.  `target`: Прототип класса.
2.  `propertyKey`: Имя метода, которому принадлежит параметр.
3.  `parameterIndex`: Порядковый индекс параметра в списке аргументов метода.

Часто используется в связке с библиотекой `reflect-metadata` для получения типов параметров во время выполнения (требует `emitDecoratorMetadata` в `tsconfig.json`).

```typescript
import "reflect-metadata"; // Важно импортировать один раз в корневом файле

const INJECTABLE_PARAMS = Symbol('injectable_params');

function injectable(target: Object, propertyKey: string | symbol, parameterIndex: number) {
    const existingInjectableParams: number[] = Reflect.getMetadata(INJECTABLE_PARAMS, target, propertyKey) || [];
    existingInjectableParams.push(parameterIndex);
    Reflect.defineMetadata(INJECTABLE_PARAMS, existingInjectableParams, target, propertyKey);

    // Можно также получить тип параметра:
    // const paramTypes: any[] = Reflect.getMetadata("design:paramtypes", target, propertyKey);
    // console.log(`Parameter at index ${parameterIndex} in method ${String(propertyKey)} has type: ${paramTypes[parameterIndex].name}`);
}

class LoggerService { log(message: string) { console.log(`[Logger]: ${message}`); } }
class DataService { getData() { return 'Some Data'; } }

class ApplicationService {
    constructor(
        @injectable private logger: LoggerService,
        @injectable private data: DataService
    ) {}

    start() {
        this.logger.log(`Starting with data: ${this.data.getData()}`);
    }
}

// В реальном DI-контейнере:
// const loggerInstance = new LoggerService();
// const dataInstance = new DataService();
// const paramsIndices: number[] = Reflect.getMetadata(INJECTABLE_PARAMS, ApplicationService.prototype, undefined) || []; // Для конструктора свойство null/undefined
// const constructorParams = Reflect.getMetadata("design:paramtypes", ApplicationService); // Получаем типы параметров конструктора
// console.log(constructorParams.map(t => t.name)); // ["LoggerService", "DataService"]
// Здесь бы мы создали ApplicationService, передавая зависимости.
```

### Продвинутые Техники и ES Декораторы (TypeScript 5.x+)

#### Фабрики Декораторов

Декораторы часто нуждаются в конфигурации. Фабрика декораторов – это функция, которая возвращает функцию-декоратор.

```typescript
type LogLevel = 'info' | 'warn' | 'error';

function logMethodFactory(level: LogLevel = 'info') {
    return function (target: Object, propertyKey: string | symbol, descriptor: PropertyDescriptor) {
        const originalMethod = descriptor.value;
        descriptor.value = function (...args: any[]) {
            console.log(`[${level.toUpperCase()}] Метод ${String(propertyKey)} вызван с: ${JSON.stringify(args)}`);
            return originalMethod.apply(this, args);
        };
        return descriptor;
    };
}

class ReportingEngine {
    @logMethodFactory('info')
    generateDailyReport(date: string) {
        return `Отчет за ${date} готов.`;
    }

    @logMethodFactory('error')
    archiveOldReports(year: number) {
        throw new Error(`Ошибка архивации за ${year} год!`);
    }
}

const engine = new ReportingEngine();
engine.generateDailyReport('2023-10-27');
try {
    engine.archiveOldReports(2020);
} catch (e) {
    // [ERROR] Метод archiveOldReports вызван с: [2020]
    // Ошибка архивации за 2020 год!
}
```

#### Порядок Применения Декораторов

Декораторы применяются в определённом порядке:
1.  Параметры, затем Метод/Свойство/Аксессор (для одного члена: снизу вверх, справа налево).
2.  Декораторы классов (сверху вниз).

#### Новый Стандарт Декораторов (ES Decorators, TypeScript 5.0+)

TypeScript 5.0 представил поддержку нового стандарта декораторов (из предложения TC39 Stage 3). Эти декораторы отличаются по сигнатуре и поведению, предлагая более явный и мощный API. Они не используют `experimentalDecorators` и не требуют `emitDecoratorMetadata` по умолчанию (хотя `reflect-metadata` по-прежнему полезен для DI).

Основные отличия:
*   Декораторы получают объект `context` с метаданными (`name`, `kind`, `addInitializer` и т.д.).
*   Для методов/свойств они возвращают *новое* объявление или `void`, а не модифицируют `descriptor` напрямую.
*   Для классов они могут возвращать новый конструктор.

Для использования нового стандарта, убедитесь, что ваш `tsconfig.json` имеет `target: es2022` или выше.

```typescript
// Декоратор метода в новом стиле
function trace(originalMethod: Function, context: ClassMethodDecoratorContext) {
    const methodName = String(context.name);
    console.log(`[ES Decorator] Декорирование метода: ${methodName}`);

    return function (this: any, ...args: any[]) {
        console.log(`[ES Decorator] Перед вызовом ${methodName} с аргументами: ${JSON.stringify(args)}`);
        const result = originalMethod.apply(this, args);
        console.log(`[ES Decorator] После вызова ${methodName}, результат: ${JSON.stringify(result)}`);
        return result;
    };
}

// Декоратор класса в новом стиле
function register(originalClass: Function, context: ClassDecoratorContext) {
    const className = String(context.name);
    context.addInitializer(() => {
        console.log(`[ES Decorator] Класс ${className} инициализирован.`);
    });
    return class extends (originalClass as any) {
        constructor(...args: any[]) {
            super(...args);
            console.log(`[ES Decorator] Создан экземпляр класса ${className}.`);
        }
    };
}


@register
class TaskManager {
    constructor(public owner: string) {}

    @trace
    addTask(taskName: string, priority: number): string {
        return `Задание "${taskName}" с приоритетом ${priority} добавлено для ${this.owner}.`;
    }
}

const manager = new TaskManager("Alice");
manager.addTask("Купить продукты", 1);
```

### Заключение и Best Practices

Декораторы – это мощный инструмент в TypeScript, позволяющий значительно улучшить организацию кода, особенно в сценариях, где требуется сквозная логика (Aspect-Oriented Programming).

*   **Используйте их разумно:** Декораторы отлично подходят для задач, которые затрагивают множество мест в коде, но не являются частью основной бизнес-логики.
*   **Чёткое назначение:** Каждый декоратор должен выполнять одну, хорошо определённую задачу.
*   **Тестирование:** Тестируйте свои декораторы так же тщательно, как и любой другой код.
*   **Разница стандартов:** Для новых проектов рассмотрите использование нового стандарта ES декораторов (TypeScript 5.0+), так как он является частью будущего стандарта JavaScript. Для работы с существующими фреймворками, такими как Angular, вам, скорее всего, придётся использовать "легаси" декораторы с `experimentalDecorators`.