## TypeScript: Enum и Literal Types – Мощь Констант и Точных Значений

![Иллюстрация к уроку](/lessons/typescript-enums.png)


В мире разработки, где критически важна стабильность и предсказуемость, TypeScript предлагает мощные инструменты для определения строгих, но гибких наборов значений. `Enum` и `Literal Types` позволяют нам отойти от "магических строк" и "магических чисел", вводя типобезопасность на уровне констант.

### Проблема без типов: Ограниченные константы и потенциальные ошибки

Без строгих типов мы часто полагаемся на строковые или числовые константы, определенные через `const` переменные или напрямую в коде. Это приводит к нескольким проблемам:
1.  **Опечатки**: Легко допустить ошибку при вводе строки, что приведет к трудноуловимым багам в рантайме.
2.  **Отсутствие автодополнения**: IDE не всегда может предложить все возможные варианты.
3.  **Неявные зависимости**: Изменение константы в одном месте может потребовать ручного поиска и обновления всех её использований.

Рассмотрим пример обработки статусов заказа:

```typescript
// Проблема: Использование "магических строк" без строгих типов
function processOrderStatus(status: string) {
    if (status === 'pending') {
        console.log('Заказ ожидает обработки...');
    } else if (status === 'active') {
        console.log('Заказ активен.');
    } else if (status === 'complete') {
        console.log('Заказ завершен.');
    } else {
        console.warn(`Неизвестный статус: ${status}`); // <-- Это может случиться из-за опечатки
    }
}

processOrderStatus('pending');
processOrderStatus('active');
processOrderStatus('compleated'); // Опечатка! TypeScript не поможет здесь без явных типов.
// Выведет "Неизвестный статус: compleated", что является ошибкой, которую сложно отловить.
```

### Решение с TypeScript: Типобезопасные Enum и Literal Types

TypeScript предоставляет два основных способа решения этой проблемы, каждый со своими особенностями.

#### Enum: Группировка связанных констант

`Enum` (перечисления) позволяют нам определить набор именованных констант. Они создают реальный объект в JavaScript рантайме, что полезно, если вам нужна возможность итерации или рефлексии.

**1. Числовые Enums (Numeric Enums)**
По умолчанию значения `Enum` являются числовыми, начиная с 0.

```typescript
// Решение: Numeric Enum
enum OrderStatus {
    PENDING,  // 0
    ACTIVE,   // 1
    COMPLETE  // 2
}

function processOrderStatusEnum(status: OrderStatus) {
    switch (status) {
        case OrderStatus.PENDING:
            console.log('Заказ ожидает обработки (Enum)...');
            break;
        case OrderStatus.ACTIVE:
            console.log('Заказ активен (Enum).');
            break;
        case OrderStatus.COMPLETE:
            console.log('Заказ завершен (Enum).');
            break;
        // TypeScript предупредит, если не все варианты OrderStatus обработаны в исчерпывающем switch
    }
}

processOrderStatusEnum(OrderStatus.PENDING); // Типобезопасно и с автодополнением
// processOrderStatusEnum('compleated'); // Ошибка TS2345: Аргумент '"compleated"' не может быть присвоен параметру типа 'OrderStatus'.
// processOrderStatusEnum(99); // Ошибка TS2345: Аргумент '99' не может быть присвоен параметру типа 'OrderStatus'.
```

**2. Строковые Enums (String Enums)**
Строковые Enums более выразительны и обычно предпочтительнее для лучшей читаемости и отладки, хотя и имеют чуть больший "вес" в рантайме.

```typescript
// String Enum: более выразительны
enum HttpMethod {
    GET = "GET",
    POST = "POST",
    PUT = "PUT",
    DELETE = "DELETE"
}

function makeHttpRequest(method: HttpMethod, url: string) {
    console.log(`Отправка ${method} запроса на ${url}`);
}

makeHttpRequest(HttpMethod.GET, '/api/users'); // Читабельно и безопасно
// makeHttpRequest("get", '/api/items'); // Ошибка TS2345: Аргумент '"get"' не может быть присвоен параметру типа 'HttpMethod'.
```

#### Literal Types: Точные значения как типы

Literal Types позволяют определить тип, который может быть только *одним конкретным значением* (строкой, числом, булевым). Чаще всего они используются в объединениях (`union types`), чтобы создать тип, который может быть одним из нескольких точных значений. Literal Types не создают нового объекта в рантайме, что делает их "легковесным" решением.

```typescript
// Решение: Literal Types для строковых значений
type AllowedStatus = "pending" | "active" | "complete";

function processOrderStatusLiteral(status: AllowedStatus) {
    if (status === 'pending') {
        console.log('Заказ ожидает обработки (Literal)...');
    } else if (status === 'active') {
        console.log('Заказ активен (Literal).');
    } else if (status === 'complete') {
        console.log('Заказ завершен (Literal).');
    }
}

processOrderStatusLiteral('pending'); // Автодополнение и типобезопасность
// processOrderStatusLiteral('compleated'); // Ошибка TS2345: Аргумент '"compleated"' не может быть присвоен параметру типа 'AllowedStatus'.

// Literal Types для числовых значений
type ResponseCode = 200 | 400 | 404 | 500;
function handleResponse(code: ResponseCode) {
    console.log(`Обработка ответа с кодом: ${code}`);
}
handleResponse(200);
// handleResponse(201); // Ошибка TS2345: Аргумент '201' не может быть присвоен параметру типа 'ResponseCode'.
```

### Продвинутые техники и Best Practices

**1. `as const` для создания Literal Union из объекта**
Это мощный способ получить Literal Union из значений объекта, используя `typeof` и индексированные доступы, при этом не создавая `enum` и сохраняя гибкость объекта.

```typescript
// Продвинутая техника: `as const`
const AVAILABLE_COLORS = {
    RED: 'red',
    GREEN: 'green',
    BLUE: 'blue'
} as const; // `as const` делает свойства объекта readonly и их значения - literal types

// Тип Color будет "red" | "green" | "blue"
type Color = typeof AVAILABLE_COLORS[keyof typeof AVAILABLE_COLORS];

function selectColor(color: Color) {
    console.log(`Выбран цвет: ${color}`);
}

selectColor(AVAILABLE_COLORS.RED); // Доступ к значению по ключу
selectColor('green');             // Прямое использование литерала
// selectColor('yellow');            // Ошибка TS2345: Аргумент '"yellow"' не может быть присвоен параметру типа 'Color'.
```

**2. `const enum`: "Исчезающие" перечисления**
`const enum` — это оптимизированная версия `enum`, которая полностью удаляется на этапе компиляции, а её использования заменяются на инлайновые значения. Это сокращает размер бандла, но лишает вас объекта в рантайме.

```typescript
// const enum: компилируется в инлайновые значения, нет объекта в рантайме
const enum LogLevel {
    DEBUG,
    INFO,
    WARN,
    ERROR
}

function logMessage(level: LogLevel, message: string) {
    if (level === LogLevel.ERROR) {
        console.error(`[ERROR] ${message}`);
    } else if (level === LogLevel.INFO) {
        console.info(`[INFO] ${message}`);
    }
}

logMessage(LogLevel.INFO, "Пользователь вошел.");
// В скомпилированном JS это будет выглядеть как:
// if (level === 3 /* LogLevel.ERROR */) { ... } else if (level === 1 /* LogLevel.INFO */) { ... }
```

**Когда что использовать?**
*   **`Enum`**: Если вам нужен реальный объект в рантайме (например, для итерации по всем значениям, или когда значения должны быть объектами, а не примитивами), или когда вы хотите четко сгруппировать связанные константы в единое сущность.
*   **`Literal Types` (включая `as const` объекты)**: Если вам нужна только типобезопасность на этапе компиляции, минимальный "вес" в рантайме, и вы хотите определить строгий набор допустимых значений. Часто предпочтительнее для простых строковых/числовых ограничений из-за меньшего оверхеда.

### Практика: Реализация типизированного API-клиента

Давайте применим полученные знания для создания типобезопасного API-клиента.

```typescript
// Практика: Типизированный API-клиент
// Используем Enum для известных и фиксированных конечных точек API
enum ApiEndpoint {
    USERS = "/api/v1/users",
    PRODUCTS = "/api/v1/products",
    ORDERS = "/api/v1/orders"
}

// Используем Literal Union для строгих методов HTTP
type HttpMethodStrict = "GET" | "POST" | "PUT" | "DELETE" | "PATCH";

interface RequestOptions<T> {
    method: HttpMethodStrict;
    endpoint: ApiEndpoint;
    headers?: Record<string, string>;
    data?: T; // Опциональные данные для POST/PUT/PATCH запросов
}

function apiClient<TResponse, TRequest = unknown>(options: RequestOptions<TRequest>): Promise<TResponse> {
    console.log(`Отправка ${options.method} запроса на ${options.endpoint}`);
    if (options.data) {
        console.log('Данные запроса:', options.data);
    }
    // Здесь была бы реальная логика fetch/axios
    return Promise.resolve({} as TResponse); // Заглушка для примера
}

// Пример использования:
interface User { id: string; name: string; email: string; }
interface NewUser { name: string; email: string; }

// Получение списка пользователей
apiClient<User[], undefined>({
    method: "GET",
    endpoint: ApiEndpoint.USERS
}).then(users => console.log('Получены пользователи:', users));

// Создание нового пользователя
apiClient<User, NewUser>({
    method: "POST",
    endpoint: ApiEndpoint.USERS,
    data: { name: "Alice", email: "alice@example.com" }
}).then(newUser => console.log('Создан пользователь:', newUser));

// При попытке использовать несуществующий метод или эндпоинт, TypeScript выдаст ошибку:
// apiClient({ method: "INVALID_METHOD", endpoint: ApiEndpoint.PRODUCTS }); // Ошибка TS2345
```

Используя `Enum` и `Literal Types`, мы создали надежный и предсказуемый интерфейс для нашего API-клиента, значительно снизив риск ошибок, связанных с опечатками или некорректными значениями.


## Интерактивный пример

<Sandpack
  template="vanilla-ts"
  files={{
    "/index.ts": `
document.body.style.fontFamily = 'sans-serif';
document.body.style.padding = '20px';
document.body.style.backgroundColor = '#282c34';
document.body.style.color = '#fff';

// Enum для статусов заказа
enum OrderStatus {
    PENDING,
    ACTIVE,
    COMPLETE,
    CANCELLED
}

// Функция для обработки статуса заказа (Enum)
function processOrderStatusEnum(status: OrderStatus): string {
    switch (status) {
        case OrderStatus.PENDING:
            return 'Заказ ожидает обработки...';
        case OrderStatus.ACTIVE:
            return 'Заказ активен.';
        case OrderStatus.COMPLETE:
            return 'Заказ завершен.';
        case OrderStatus.CANCELLED:
            return 'Заказ отменен.';
        default:
            return 'Неизвестный статус.';
    }
}

// Literal Types для ролей пользователей
type UserRole = 'admin' | 'editor' | 'viewer';

// Функция для проверки роли пользователя (Literal Types)
function checkUserRole(role: UserRole): string {
    switch (role) {
        case 'admin':
            return 'Пользователь имеет права администратора.';
        case 'editor':
            return 'Пользователь имеет права редактора.';
        case 'viewer':
            return 'Пользователь имеет права просмотра.';
    }
}

// Создаем элементы интерфейса
const enumSelect = document.createElement('select');
enumSelect.id = 'enumSelect';

const rolesSelect = document.createElement('select');
rolesSelect.id = 'rolesSelect';

const enumResult = document.createElement('div');
enumResult.id = 'enumResult';
enumResult.style.marginTop = '10px';

const rolesResult = document.createElement('div');
rolesResult.id = 'rolesResult';
rolesResult.style.marginTop = '10px';

// Заполняем options для enumSelect
const enumOptions = Object.values(OrderStatus).filter(v => typeof v === 'string');
enumOptions.forEach(option => {
    const opt = document.createElement('option');
    opt.value = option;
    opt.textContent = option;
    enumSelect.appendChild(opt);
});

// Заполняем options для rolesSelect
const roles: UserRole[] = ['admin', 'editor', 'viewer'];
roles.forEach(role => {
    const opt = document.createElement('option');
    opt.value = role;
    opt.textContent = role;
    rolesSelect.appendChild(opt);
});

// Обработчик изменения enumSelect
enumSelect.addEventListener('change', () => {
    const selectedStatus = enumSelect.value as keyof typeof OrderStatus;
    const statusValue = OrderStatus[selectedStatus];
    enumResult.textContent = processOrderStatusEnum(statusValue);
});

// Обработчик изменения rolesSelect
rolesSelect.addEventListener('change', () => {
    const selectedRole = rolesSelect.value as UserRole;
    rolesResult.textContent = checkUserRole(selectedRole);
});

// Добавляем элементы на страницу
const enumLabel = document.createElement('label');
enumLabel.textContent = 'Выберите статус заказа:';
enumLabel.style.display = 'block';
enumLabel.style.marginBottom = '5px';
document.body.appendChild(enumLabel);
document.body.appendChild(enumSelect);
document.body.appendChild(enumResult);

const rolesLabel = document.createElement('label');
rolesLabel.textContent = 'Выберите роль пользователя:';
rolesLabel.style.display = 'block';
rolesLabel.style.marginTop = '20px';
rolesLabel.style.marginBottom = '5px';
document.body.appendChild(rolesLabel);
document.body.appendChild(rolesSelect);
document.body.appendChild(rolesResult);
`
  }}
  options={{
    showNavigator: false,
    showLineNumbers: true,
    editorHeight: 400
  }}
/>
