## TypeScript: Мощь Utility Types

В мире разработки, где доминируют данные и их преобразования, TypeScript предлагает мощный арсенал инструментов для работы с типами данных без необходимости их ручного переопределения. Эти инструменты называются "Utility Types". Они позволяют манипулировать существующими типами, создавая новые, более специфичные или обобщенные типы на лету, что значительно повышает типобезопасность, переиспользуемость кода и его читаемость.

### 1. Проблема без Utility Types: Ручное дублирование и риск ошибок

Представим, что у нас есть базовый интерфейс пользователя:

```typescript
interface User {
  id: string;
  name: string;
  email: string;
  passwordHash: string;
  createdAt: Date;
  updatedAt?: Date;
}
```

Теперь нам нужно создать тип для:
1.  Обновления пользователя (все поля необязательны).
2.  Краткого представления пользователя (только `id` и `name`).
3.  Публичного представления пользователя (без `passwordHash`).

Без Utility Types, мы могли бы делать это так:

```typescript
// Ручное создание типа для обновления (все поля необязательны)
interface UserUpdateManual {
  id?: string;
  name?: string;
  email?: string;
  passwordHash?: string;
  createdAt?: Date;
  updatedAt?: Date;
}

// Ручное создание типа для краткого представления
interface UserSummaryManual {
  id: string;
  name: string;
}

// Ручное создание типа для публичного представления
interface PublicUserManual {
  id: string;
  name: string;
  email: string;
  createdAt: Date;
  updatedAt?: Date;
}
```

Такой подход приводит к дублированию кода, увеличивает вероятность ошибок при изменении базового `User` интерфейса и снижает читаемость.

### 2. Решение с TypeScript Utility Types

TypeScript предоставляет ряд встроенных `Utility Types`, которые позволяют элегантно решать вышеописанные задачи.

#### `Partial<T>`: Все свойства становятся необязательными

`Partial<T>` создает тип, в котором все свойства типа `T` становятся необязательными. Идеально подходит для DTO (Data Transfer Objects) обновлений.

```typescript
type UserUpdate = Partial<User>;

const userPatch: UserUpdate = { email: 'new.email@example.com' }; // Типобезопасно
// const invalidPatch: UserUpdate = { nonExistentField: 'value' }; // Ошибка: Object literal may only specify known properties
```

#### `Readonly<T>`: Все свойства становятся доступными только для чтения

`Readonly<T>` создает тип, в котором все свойства типа `T` становятся `readonly`. Это полезно для объектов, которые не должны изменяться после создания, например, кешированных данных.

```typescript
type ImmutableUser = Readonly<User>;

const userProfile: ImmutableUser = {
  id: 'u123', name: 'Alice', email: 'a@example.com',
  passwordHash: 'hashed', createdAt: new Date()
};

// userProfile.name = 'Bob'; // Ошибка: Cannot assign to 'name' because it is a read-only property.
```

#### `Pick<T, K>`: Выбор подмножества свойств

`Pick<T, K>` создает тип, выбирая только указанные свойства `K` из типа `T`.

```typescript
type UserSummary = Pick<User, 'id' | 'name'>;

const summary: UserSummary = { id: 'u123', name: 'Alice' }; // Типобезопасно
// const invalidSummary: UserSummary = { id: 'u123', email: 'a@example.com' }; // Ошибка: Object literal may only specify known properties
```

#### `Omit<T, K>`: Исключение подмножества свойств

`Omit<T, K>` создает тип, исключая указанные свойства `K` из типа `T`.

```typescript
type PublicUser = Omit<User, 'passwordHash'>;

const publicData: PublicUser = {
  id: 'u123', name: 'Alice', email: 'a@example.com', createdAt: new Date()
};
// const invalidPublicData: PublicUser = { id: 'u123', passwordHash: 'hash' }; // Ошибка: Object literal may only specify known properties
```

### 3. Продвинутые техники и комбинации

Utility Types можно комбинировать для создания сложных и точных типов.

#### `Record<K, T>`: Объект со строго типизированными ключами и значениями

`Record<K, T>` создает тип объекта, где ключи должны быть типа `K`, а значения — типа `T`.

```typescript
type UserStatus = 'active' | 'inactive' | 'pending';

// Объект, где ключи - это UserStatus, а значения - число пользователей
type UserCountsByStatus = Record<UserStatus, number>;

const counts: UserCountsByStatus = {
  active: 100,
  inactive: 20,
  pending: 5
};
// const invalidCounts: UserCountsByStatus = { active: 100, unknown: 5 }; // Ошибка: Object literal may only specify known properties
```

#### `Exclude<T, U>`: Исключение типов из объединения (Union Type)

`Exclude<T, U>` создает тип, исключая из объединения `T` все типы, которые присваиваются `U`.

```typescript
type AllPermissions = 'read' | 'write' | 'delete' | 'admin';
type BasicPermissions = Exclude<AllPermissions, 'admin'>; // 'read' | 'write' | 'delete'
```

#### `Extract<T, U>`: Извлечение типов из объединения

`Extract<T, U>` создает тип, извлекая из объединения `T` все типы, которые присваиваются `U`.

```typescript
type HttpMethods = 'GET' | 'POST' | 'PUT' | 'DELETE' | 'OPTIONS';
type IdempotentMethods = Extract<HttpMethods, 'GET' | 'PUT' | 'DELETE'>; // 'GET' | 'PUT' | 'DELETE'
```

#### `NonNullable<T>`: Удаление `null` и `undefined`

`NonNullable<T>` создает тип, исключая `null` и `undefined` из типа `T`.

```typescript
type OptionalString = string | null | undefined;
type RequiredString = NonNullable<OptionalString>; // string
```

#### `Parameters<T>` и `ReturnType<T>`: Работа с сигнатурами функций

Эти Utility Types позволяют извлекать типы параметров и возвращаемое значение функции.

```typescript
function greet(name: string, age: number): string {
  return `Hello, ${name}! You are ${age} years old.`;
}

type GreetParams = Parameters<typeof greet>; // [name: string, age: number]
type GreetReturn = ReturnType<typeof greet>; // string

const args: GreetParams = ['Bob', 30];
const result: GreetReturn = greet(...args); // 'Hello, Bob! You are 30 years old.'
```

### 4. Практика и Best Practices

*   **Гибкие DTO для обновлений**: Комбинируйте `Partial` и `Omit` для сценариев, где некоторые поля могут быть обязательны, а другие должны быть полностью исключены.
    ```typescript
    interface Product {
      id: string;
      name: string;
      description: string;
      price: number;
      categoryId: string;
      createdAt: Date;
    }

    // Обновление продукта: все поля опциональны, но `createdAt` нельзя изменить
    type ProductUpdateDTO = Partial<Omit<Product, 'id' | 'createdAt'>>;

    const update: ProductUpdateDTO = { price: 29.99, description: 'Updated description' };
    // const invalidUpdate: ProductUpdateDTO = { createdAt: new Date() }; // Ошибка
    ```
*   **`Awaited<T>`**: Для асинхронного кода, чтобы получить тип значения, которое разрешит `Promise`. (Добавлено в TypeScript 4.5)
    ```typescript
    async function fetchData(): Promise<{ data: string }> {
      return { data: 'some data' };
    }

    type FetchedDataType = Awaited<ReturnType<typeof fetchData>>; // { data: string }
    ```

Использование Utility Types — это признак зрелого и поддерживаемого TypeScript кода. Они сокращают бойлерплейт, усиливают типобезопасность при преобразовании данных и делают намерения разработчика кристально ясными. Освоив их, вы сможете писать более мощные, гибкие и надежные приложения на TypeScript.