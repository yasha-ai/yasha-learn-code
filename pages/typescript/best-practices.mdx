## TypeScript: Best Practices для создания надежного и масштабируемого кода

![Иллюстрация к уроку](/lessons/typescript-best-practices.png)


TypeScript, в основе своей, призван помочь разработчикам создавать более надежный и предсказуемый код. Однако, чтобы полностью раскрыть его потенциал, важно следовать определенным "лучшим практикам". Этот урок погрузит вас в фундаментальные и продвинутые техники, которые сделают ваш TypeScript-код более безопасным, читаемым и легко поддерживаемым.

### 1. Проблема: Дикий запад JavaScript (Без типов)

В чистом JavaScript легко столкнуться с ошибками во время выполнения из-за неверных предположений о типах данных. Отсутствие статической проверки делает рефакторинг рискованным, а отладку — трудоемкой.

Рассмотрим простой пример обработки пользовательских данных:

```javascript
// userProcessor.js
function processUserData(data) {
  // Что, если 'data' не объект? Или не имеет 'name' или 'email'?
  if (data && typeof data.name === 'string' && typeof data.email === 'string') {
    const formattedName = data.name.trim();
    const domain = data.email.split('@')[1];
    console.log(`User: ${formattedName}, Domain: ${domain}`);
    return { success: true, user: { name: formattedName, domain } };
  } else {
    console.error("Invalid user data provided.");
    return { success: false, error: "Invalid data" };
  }
}

processUserData({ name: "   Alice   ", email: "alice@example.com" });
processUserData({ name: "Bob" }); // Ошибка: email is undefined при вызове split()
processUserData("Charlie"); // Ошибка: data.name is undefined
```

Этот код изобилует ручными проверками, которые легко пропустить, и он все еще подвержен ошибкам.

### 2. Решение: Фундаментальная типобезопасность с TypeScript

TypeScript позволяет нам формализовать ожидания от данных, перемещая многие проверки в этап компиляции.

```typescript
// userProcessor.ts
interface UserInput {
  name: string;
  email: string;
}

interface ProcessedUser {
  name: string;
  domain: string;
}

interface ProcessingResult {
  success: boolean;
  user?: ProcessedUser;
  error?: string;
}

function processUserData(data: UserInput): ProcessingResult {
  // TypeScript уже гарантирует, что data имеет name и email типа string.
  // Нет необходимости в runtime проверках 'typeof data.name === 'string''
  const formattedName = data.name.trim();
  const domain = data.email.split('@')[1]; // Здесь все еще возможен runtime-риск, если email невалиден
                                          // но это уже другая проблема - валидация данных, а не типизация.

  return { success: true, user: { name: formattedName, domain } };
}

// Теперь ошибки обнаруживаются на этапе компиляции:
processUserData({ name: "   Alice   ", email: "alice@example.com" }); // OK
// processUserData({ name: "Bob" }); // Ошибка компиляции: Property 'email' is missing
// processUserData("Charlie"); // Ошибка компиляции: Argument of type 'string' is not assignable
```

### 3. Продвинутые техники и лучшие практики

#### 3.1. Строгий режим компилятора (`strict: true`)

Включение `strict: true` в вашем `tsconfig.json` активирует набор важных проверок, таких как `noImplicitAny`, `strictNullChecks`, `strictFunctionTypes` и другие. Это наиболее важная практика для надежного кода.

```json
// tsconfig.json
{
  "compilerOptions": {
    "target": "es2020",
    "module": "commonjs",
    "strict": true, // Это включает множество полезных проверок
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true
  }
}
```

#### 3.2. Используйте `const` и `readonly`

Для данных, которые не должны изменяться, используйте `const` для переменных и `readonly` для свойств объектов или элементов кортежей.

```typescript
type Point = readonly [number, number]; // Кортеж только для чтения

const origin: Point = [0, 0];
// origin[0] = 1; // Ошибка компиляции: Cannot assign to '0' because it is a read-only property.

interface Config {
  readonly apiUrl: string;
  timeout: number;
}

const appConfig: Config = {
  apiUrl: "https://api.example.com",
  timeout: 5000,
};

// appConfig.apiUrl = "https://new.api"; // Ошибка компиляции
appConfig.timeout = 10000; // OK
```

#### 3.3. Объединения (`Union Types`) и Дискриминирующие объединения (`Discriminated Unions`)

Для обработки данных, которые могут иметь несколько форм, используйте объединения. Дискриминирующие объединения — мощный паттерн для безопасной работы с ними.

```typescript
interface SuccessResponse {
  status: "success";
  data: any;
}

interface ErrorResponse {
  status: "error";
  message: string;
  errorCode: number;
}

type ApiResponse = SuccessResponse | ErrorResponse;

function handleResponse(response: ApiResponse) {
  if (response.status === "success") {
    // TypeScript сужает тип до SuccessResponse
    console.log("Data received:", response.data);
  } else {
    // TypeScript сужает тип до ErrorResponse
    console.error(`Error ${response.errorCode}: ${response.message}`);
  }
}

handleResponse({ status: "success", data: { user: "Alice" } });
handleResponse({ status: "error", message: "Not found", errorCode: 404 });
// handleResponse({ status: "pending" }); // Ошибка компиляции: Type '"pending"' is not assignable to type '"success" | "error"'
```

#### 3.4. Утилитарные типы (`Utility Types`)

TypeScript предоставляет набор встроенных утилитарных типов для общих преобразований типов.

```typescript
interface UserProfile {
  id: string;
  name: string;
  email: string;
  isActive: boolean;
}

// Partial<T>: делает все свойства T необязательными
type PartialUserProfile = Partial<UserProfile>;
// { id?: string; name?: string; email?: string; isActive?: boolean; }

const userUpdate: PartialUserProfile = { email: "new@example.com" }; // OK

// Pick<T, K>: выбирает набор свойств K из T
type UserBasicInfo = Pick<UserProfile, "name" | "email">;
// { name: string; email: string; }

// Omit<T, K>: исключает набор свойств K из T
type UserSensitiveInfo = Omit<UserProfile, "name" | "email">;
// { id: string; isActive: boolean; }

// Readonly<T>: делает все свойства T только для чтения
type ImmutableUserProfile = Readonly<UserProfile>;
```

#### 3.5. Оператор `satisfies` (TS 4.9+)

`satisfies` позволяет проверить, что выражение соответствует типу, не сужая при этом его исходный литеральный тип. Полезно для обеспечения соответствия объекта интерфейсу, сохраняя при этом более точные типы.

```typescript
type Color = "red" | "green" | "blue";

const palette = {
  primary: "red",
  secondary: "green",
  accent: "blue",
  neutral: "gray" // Ошибка, если тип 'Color' не позволяет 'gray'
} satisfies Record<string, Color | string>;
// `palette` здесь имеет точный тип `{ primary: "red"; ...; neutral: "gray"; }`
// но при этом TS проверяет, что все его значения соответствуют `Color | string`.

// Если бы мы использовали `as`, то `palette.primary` стал бы просто `Color`, теряя "red".
// const paletteAs: Record<string, Color | string> = { primary: "red", secondary: "green", accent: "blue", neutral: "gray" };
// Тип `paletteAs.primary` был бы `Color | string` (т.е. "red" | "green" | "blue" | string), что менее точно.
```

### 4. Практика и дальнейшее развитие

Применяйте эти практики в своих проектах:

*   Начинайте с `strict: true` в новом проекте.
*   Всегда явно типизируйте параметры функций и возвращаемые значения.
*   Используйте интерфейсы или псевдонимы типов для сложных структур данных.
*   Отдавайте предпочтение объединениям и дискриминирующим объединениям, а не перегрузкам функций или `any`.
*   Изучайте и применяйте утилитарные типы.
*   Используйте `const` и `readonly` везде, где это уместно, для создания иммутабельных структур.

Следование этим рекомендациям не только уменьшит количество ошибок в вашем коде, но и значительно улучшит его читаемость, поддерживаемость и масштабируемость.


## Интерактивный пример

<Sandpack
  template="vanilla-ts"
  files={{
    "/index.ts": `
// index.ts
// TypeScript: Best Practices для создания надежного и масштабируемого кода

// 1. Проблема: Дикий запад JavaScript (Без типов)
// В чистом JavaScript легко столкнуться с ошибками во время выполнения.

// 2. Решение: Фундаментальная типобезопасность с TypeScript
// TypeScript позволяет нам формализовать ожидания от данных.

// Определяем интерфейсы для входных и обработанных данных пользователя
interface UserInput {
  name: string;
  email: string;
}

interface ProcessedUser {
  name: string;
  domain: string;
}

interface ProcessingResult {
  success: boolean;
  user?: ProcessedUser;
  error?: string;
}

// Функция для обработки данных пользователя
function processUserData(data: UserInput): ProcessingResult {
  const formattedName = data.name.trim();
  const domain = data.email.split('@')[1];

  return { success: true, user: { name: formattedName, domain } };
}

// Функция для отображения результатов в HTML
function displayResult(result: ProcessingResult): void {
  const resultElement = document.getElementById("result");
  if (!resultElement) return;

  if (result.success) {
    resultElement.textContent = \`Успех! Имя: \${'result.user.name'}, Домен: \${'result.user.domain'}\`;
  } else {
    resultElement.textContent = \`Ошибка: \${'result.error'}\`;
  }
}

// Функция для обработки ввода пользователя
function handleUserInput(): void {
  const nameInput = document.getElementById("name") as HTMLInputElement;
  const emailInput = document.getElementById("email") as HTMLInputElement;

  const name = nameInput.value;
  const email = emailInput.value;

  try {
    const result = processUserData({ name, email });
    displayResult(result);
  } catch (error) {
    displayResult({ success: false, error: (error as Error).message });
  }
}

// Назначаем обработчик события для кнопки
const processButton = document.getElementById("processButton");
if (processButton) {
  processButton.addEventListener("click", handleUserInput);
}

// Пример использования (закомментирован, чтобы не мешать интерактивности)
// const result1 = processUserData({ name: "   Alice   ", email: "alice@example.com" });
// console.log(result1);

// const result2 = processUserData({ name: "Bob", email: "bob@example.com" }); // OK теперь с email
// console.log(result2);

// const result3 = processUserData("Charlie"); // Ошибка компиляции: Argument of type 'string' is not assignable to parameter of type 'UserInput'
// console.log(result3);

// 3. Продвинутые техники и лучшие практики (будут добавлены позже)
`
    ,
    "/index.html": `
<!DOCTYPE html>
<html>
<head>
  <title>TypeScript Best Practices</title>
  <style>
    body {
      font-family: sans-serif;
      padding: 20px;
      background-color: #222;
      color: #eee;
    }
    input {
      margin-bottom: 10px;
      padding: 5px;
      border: 1px solid #555;
      background-color: #333;
      color: #eee;
    }
    button {
      padding: 5px 10px;
      background-color: #4CAF50;
      color: white;
      border: none;
      cursor: pointer;
    }
    #result {
      margin-top: 10px;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <h1>TypeScript: Best Practices</h1>
  <label for="name">Имя:</label><br>
  <input type="text" id="name" name="name"><br>
  <label for="email">Email:</label><br>
  <input type="email" id="email" name="email"><br>
  <button id="processButton">Обработать</button>
  <div id="result"></div>
  <script src="index.ts"></script>
<\/body>
</html>
`
  }}
  options={{
    showNavigator: false,
    showLineNumbers: true,
    editorHeight: 400
  }}
/>
