## TypeScript: Интерфейсы


![Иллюстрация к уроку](/lessons/interfaces.png)
Интерфейсы в TypeScript — мощный инструмент для описания формы объектов. Они позволяют задавать контракты, которым должны соответствовать объекты, функции или классы, обеспечивая типобезопасность и улучшая читаемость кода.

### Проблема без типов

Без строгой типизации легко столкнуться с ошибками, когда ожидаемая структура объекта не соблюдается.

```typescript
// JavaScript-подобный код без строгой структуры
function printUserDetails(user: any) {
    // В runtime могут быть ошибки, если user.contact или user.contact.email отсутствуют
    console.log(`Имя: ${user.firstName}, Email: ${user.contact.email}`);
}

const customer = {
    firstName: "Иван",
    lastName: "Петров",
    contact: { email: "ivan@example.com" }
};

const guest = {
    first: "Гость", // Опечатка, должно быть firstName
    email: "guest@example.com" // Не вложен в contact
};

printUserDetails(customer); // Отработает
// printUserDetails(guest); // Ошибка выполнения: Cannot read properties of undefined (reading 'email')
```
Такой код подвержен ошибкам времени выполнения, которые TypeScript призван предотвращать.

### Введение в Интерфейсы

Интерфейс описывает минимальный набор свойств и методов, которые должен иметь объект. Компилятор TypeScript проверяет, соответствует ли объект этому контракту.

```typescript
interface User {
    id: number;
    firstName: string;
    lastName: string;
    email: string;
    isActive?: boolean; // Необязательное свойство
}

function printUserSummary(user: User) {
    console.log(`ID: ${user.id}, Имя: ${user.firstName} ${user.lastName}, Email: ${user.email}`);
    if (user.isActive) {
        console.log("Статус: Активен");
    }
}

const adminUser: User = {
    id: 1, firstName: "Алексей", lastName: "Смирнов", email: "alexey@domain.com", isActive: true
};

const guestUser: User = {
    id: 2, firstName: "Анна", lastName: "Иванова", email: "anna@domain.com"
};

printUserSummary(adminUser);
printUserSummary(guestUser);

// const invalidUser: User = {
//     id: 3,
//     name: "Ольга" // Ошибка компиляции: "name" не существует в типе "User", "firstName" отсутствует
// };
```

### Типы Свойств

*   **Необязательные свойства (`?`):** Свойство может быть пропущено.
*   **Свойства только для чтения (`readonly`):** Значение свойства может быть присвоено только при создании объекта.

```typescript
interface Product {
    readonly productId: string;
    name: string;
    price: number;
    description?: string;
}

const myProduct: Product = {
    productId: "SKU-001",
    name: "Ноутбук",
    price: 1200
};

// myProduct.productId = "SKU-002"; // Ошибка: Cannot assign to 'productId' because it is a read-only property.
myProduct.name = "Ультрабук"; // Допустимо
```

### Интерфейсы как Типы Функций

Интерфейсы могут описывать сигнатуры функций, задавая типы аргументов и возвращаемого значения.

```typescript
interface StringValidator {
    (input: string): boolean;
}

const startsWithA: StringValidator = (text) => text.startsWith('A');
const hasLengthGreaterThanFive: StringValidator = (text) => text.length > 5;

console.log(startsWithA("Apple")); // true
console.log(hasLengthGreaterThanFive("Banana")); // true
```

### Индексируемые Типы (Index Signatures)

Используются, когда заранее неизвестны имена всех свойств объекта, но известен их тип и тип их значений.

```typescript
interface StringMap {
    [key: string]: string; // Ключ - строка, значение - строка
}

const userSettings: StringMap = {
    theme: "dark",
    language: "en-US",
    fontSize: "16px"
};

console.log(userSettings["theme"]); // dark

interface NumberIndexedArray {
    [index: number]: string; // Ключ - число, значение - строка
}

const items: NumberIndexedArray = ["Первый", "Второй", "Третий"];
console.log(items[1]); // Второй
```

### Расширение Интерфейсов (`extends`)

Интерфейсы могут наследовать свойства других интерфейсов, что позволяет создавать более специфичные типы на основе общих. Допускается множественное наследование.

```typescript
interface Shape {
    color: string;
}

interface HasArea {
    getArea(): number;
}

interface Circle extends Shape, HasArea {
    radius: number;
}

const myCircle: Circle = {
    color: "blue",
    radius: 10,
    getArea: () => Math.PI * 10 * 10
};

console.log(myCircle.color); // blue
console.log(myCircle.getArea()); // ~314.15
```

### Реализация Интерфейсов Классами (`implements`)

Классы могут реализовывать интерфейсы, гарантируя, что они предоставляют все свойства и методы, описанные в интерфейсе.

```typescript
interface Logger {
    log(message: string): void;
    warn(message: string): void;
}

class ConsoleLogger implements Logger {
    log(message: string): void {
        console.log(`[LOG]: ${message}`);
    }
    warn(message: string): void {
        console.warn(`[WARN]: ${message}`);
    }
}

const logger: Logger = new ConsoleLogger();
logger.log("Приложение запущено.");
logger.warn("Низкий уровень памяти!");
```

### Продвинутые Техники

**Полиморфный `this`:** Позволяет методам интерфейса возвращать `this`, что особенно полезно для построителей (builders) или текучих интерфейсов (fluent APIs).

```typescript
interface Chainable<T> {
    set(key: string, value: any): this; // Возвращает тип текущего объекта
    get(key: string): any;
    build(): T;
}

class ConfigBuilder implements Chainable<{ [key: string]: any }> {
    private config: { [key: string]: any } = {};

    set(key: string, value: any): this {
        this.config[key] = value;
        return this;
    }

    get(key: string): any {
        return this.config[key];
    }

    build(): { [key: string]: any } {
        return { ...this.config };
    }
}

const myConfig = new ConfigBuilder()
    .set("timeout", 5000)
    .set("retries", 3)
    .build();

console.log(myConfig); // { timeout: 5000, retries: 3 }
```

### Практика

Создайте набор интерфейсов для описания онлайн-магазина. Вам понадобятся:
1.  `ProductCategory`: Описывает категорию товара (id: `string`, name: `string`).
2.  `Product`: Описывает товар (id: `string`, name: `string`, price: `number`, category: `ProductCategory`, optional description: `string`, readonly sku: `string`).
3.  `ShoppingCartItem`: Описывает товар в корзине (product: `Product`, quantity: `number`).
4.  `ShoppingCart`: Описывает корзину (items: `ShoppingCartItem[]`, метод `getTotal()`: `number`).

Реализуйте класс `OnlineStoreCart`, который имплементирует `ShoppingCart`.
```typescript
// Ожидаемый код для практики:

/*
interface ProductCategory {
    id: string;
    name: string;
}

interface Product {
    id: string;
    name: string;
    price: number;
    category: ProductCategory;
    description?: string;
    readonly sku: string;
}

interface ShoppingCartItem {
    product: Product;
    quantity: number;
}

interface ShoppingCart {
    items: ShoppingCartItem[];
    getTotal(): number;
}

class OnlineStoreCart implements ShoppingCart {
    items: ShoppingCartItem[] = [];

    constructor(initialItems: ShoppingCartItem[] = []) {
        this.items = initialItems;
    }

    addItem(item: Product, quantity: number): void {
        const existingItem = this.items.find(i => i.product.id === item.id);
        if (existingItem) {
            existingItem.quantity += quantity;
        } else {
            this.items.push({ product: item, quantity });
        }
    }

    getTotal(): number {
        return this.items.reduce((total, item) => total + item.product.price * item.quantity, 0);
    }
}

// Пример использования
const electronicsCategory: ProductCategory = { id: "C1", name: "Электроника" };
const laptop: Product = {
    id: "P1", name: "Ноутбук Pro", price: 1500, category: electronicsCategory,
    description: "Мощный ноутбук для профессионалов", sku: "NBP-001"
};
const mouse: Product = {
    id: "P2", name: "Беспроводная мышь", price: 50, category: electronicsCategory, sku: "MWS-005"
};

const cart = new OnlineStoreCart();
cart.addItem(laptop, 1);
cart.addItem(mouse, 2);

console.log("Товаров в корзине:", cart.items.length); // 2
console.log("Общая стоимость:", cart.getTotal()); // 1600
*/
```