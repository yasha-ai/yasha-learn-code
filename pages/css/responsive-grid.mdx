## CSS: Отзывчивые сетки без медиа-запросов


![Иллюстрация к уроку](/lessons/css-responsive-grid.png)
В этом уроке мы рассмотрим, как создавать отзывчивые сетки, которые адаптируются к различным размерам экранов без использования медиа-запросов. Мы изучим методы, позволяющие создавать гибкие и адаптивные макеты, которые хорошо выглядят на любых устройствах.

### Гибкие сетки с помощью `grid-template-columns: repeat()` и `minmax()`

Ключевая идея заключается в использовании функций `repeat()` и `minmax()` в свойстве `grid-template-columns`.  `repeat()` позволяет повторять шаблон колонок, а `minmax()` задает минимальный и максимальный размер для каждой колонки.

```html
<div class="grid-container">
  <div>Item 1</div>
  <div>Item 2</div>
  <div>Item 3</div>
  <div>Item 4</div>
  <div>Item 5</div>
  <div>Item 6</div>
</div>
```

```css
.grid-container {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); /* Магия здесь! */
  grid-gap: 10px;
}

.grid-container > div {
  background-color: #f0f0f0;
  padding: 20px;
  text-align: center;
}
```

**Объяснение:**

*   `display: grid;`:  Определяет контейнер как grid-контейнер.
*   `grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));`:  Здесь происходит основная работа.
    *   `repeat(auto-fit, ...)`:  Создает столько колонок, сколько поместится в контейнер.  `auto-fit` означает, что пустые колонки схлопываются до 0, что позволяет элементам занимать все доступное пространство.  `auto-fill` работает похоже, но сохраняет пустые колонки. Разница становится заметна, когда элементов меньше, чем потенциально может поместиться колонок.
    *   `minmax(200px, 1fr)`:  Каждая колонка будет иметь минимальный размер 200 пикселей и максимальный размер `1fr` (одна фракция доступного пространства).  Это означает, что колонки будут расширяться, чтобы заполнить пространство, но никогда не будут меньше 200 пикселей.

### Пример с `auto-fill`

Чтобы понять разницу между `auto-fit` и `auto-fill`, заменим `auto-fit` на `auto-fill`:

```css
.grid-container {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
  grid-gap: 10px;
}
```

Если элементов будет меньше, чем колонок, которые могут поместиться (исходя из `minmax`), то `auto-fill` оставит пустые колонки, а `auto-fit` схлопнет их.

### Жизненный пример

Этот подход широко используется в различных веб-сайтах и фреймворках. Например, он часто применяется для создания галерей изображений, где количество изображений может варьироваться, и нужно, чтобы они аккуратно располагались в ряд, адаптируясь к ширине экрана.  Многие UI-библиотеки, такие как Bootstrap и Material UI, используют аналогичные техники для создания отзывчивых layout-ов.  В частности, в системах управления контентом (CMS) часто используют такой подход для отображения списка статей или продуктов.

### Ключевые моменты

*   `repeat(auto-fit, minmax(...))` - мощный инструмент для создания отзывчивых сеток без медиа-запросов.
*   `minmax()` позволяет задать минимальный и максимальный размер для колонок.
*   `auto-fit` схлопывает пустые колонки, а `auto-fill` их сохраняет.
*   Этот метод часто используется в галереях изображений, UI-библиотеках и CMS.
*   Позволяет создавать адаптивные макеты, которые хорошо выглядят на разных устройствах.



## Интерактивный пример

<Sandpack
  template="vanilla"
  files={{
    "/index.html": `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Отзывчивая сетка без медиа-запросов</title>
  <link rel="stylesheet" href="/styles.css">
</head>
<body>
  <h1>Отзывчивая сетка</h1>

  <div class="controls">
    <label for="itemCount">Количество элементов:</label>
    <input type="number" id="itemCount" value="6" min="1">
    <button id="updateGrid">Обновить сетку</button>
  </div>

  <div class="grid-container" id="gridContainer">
    <!-- Элементы сетки будут добавлены здесь -->
  </div>

  <script src="/index.js"></script>
</body>
</html>`,
    "/styles.css": `body {
  font-family: sans-serif;
  background-color: #222;
  color: #eee;
  padding: 20px;
}

.grid-container {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  grid-gap: 10px;
  margin-top: 20px;
}

.grid-container > div {
  background-color: #333;
  padding: 20px;
  text-align: center;
  border-radius: 5px;
}

.controls {
  display: flex;
  flex-direction: column;
  margin-bottom: 10px;
}

.controls label {
  margin-bottom: 5px;
}

.controls input[type="number"] {
  padding: 5px;
  border: 1px solid #555;
  background-color: #444;
  color: #eee;
  border-radius: 3px;
  margin-bottom: 10px;
}

.controls button {
  padding: 10px 15px;
  background-color: #4CAF50;
  color: white;
  border: none;
  border-radius: 5px;
  cursor: pointer;
}

.controls button:hover {
  background-color: #367c39;
}
`,
    "/index.js": `document.addEventListener('DOMContentLoaded', () => {
  const gridContainer = document.getElementById('gridContainer');
  const itemCountInput = document.getElementById('itemCount');
  const updateGridButton = document.getElementById('updateGrid');

  function generateGridItems(count) {
    gridContainer.innerHTML = ''; // Очищаем контейнер

    for (let i = 1; i <= count; i++) {
      const div = document.createElement('div');
      div.textContent = \`Item \${'i'}\`;
      gridContainer.appendChild(div);
    }
  }

  // Инициализация сетки при загрузке страницы
  generateGridItems(itemCountInput.value);

  updateGridButton.addEventListener('click', () => {
    const itemCount = parseInt(itemCountInput.value);
    if (itemCount > 0) {
      generateGridItems(itemCount);
    } else {
      alert('Пожалуйста, введите положительное число.');
    }
  });
});
`
  }}
  options={{
    showNavigator: false,
    showLineNumbers: true,
    editorHeight: 400
  }}
/>
