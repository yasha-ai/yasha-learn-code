## CSS: View Transitions API - Плавные переходы между состояниями


![Иллюстрация к уроку](/lessons/css-view-transitions.png)
View Transitions API позволяет создавать плавные и визуально приятные переходы между различными состояниями вашего веб-приложения. Вместо резких изменений, элементы на странице будут анимированно перемещаться, изменяться в размере или исчезать, делая пользовательский опыт более интерактивным и современным.

### Что такое View Transitions API?

View Transitions API – это новый способ управления переходами между состояниями DOM.  Представьте, что у вас есть список товаров, и при нажатии на один из них открывается страница с детальным описанием.  Без View Transitions API изменение контента произошло бы мгновенно. С API вы можете плавно "переместить" изображение товара из списка на страницу с деталями, создавая ощущение целостности и связности интерфейса.

### Основные концепции и примеры

Основная функция API – `document.startViewTransition()`. Она принимает callback-функцию, которая выполняет изменения DOM.  API захватывает состояние страницы до и после изменений, а затем анимирует разницу между ними.

**Пример 1: Простой переход между двумя состояниями**

```html
<!DOCTYPE html>
<html>
<head>
  <title>View Transitions Example</title>
  <style>
    body {
      font-family: sans-serif;
    }
    .box {
      width: 100px;
      height: 100px;
      background-color: lightblue;
      transition: background-color 0.5s ease;
    }
    .box.changed {
      background-color: lightcoral;
    }
  </style>
</head>
<body>
  <div class="box" id="myBox"></div>
  <button id="myButton">Изменить цвет</button>

  <script>
    const button = document.getElementById('myButton');
    const box = document.getElementById('myBox');

    button.addEventListener('click', () => {
      document.startViewTransition(() => {
        box.classList.toggle('changed'); // Изменяем состояние DOM
      });
    });
  </script>
</body>
</html>
```

В этом примере при нажатии на кнопку цвет квадрата плавно меняется.  `document.startViewTransition()`  выполняет callback, в котором мы добавляем/удаляем класс `changed`, который, в свою очередь, меняет цвет фона с помощью CSS transition.

**Пример 2:  Переход с использованием `::view-transition-old` и `::view-transition-new`**

Для более тонкого контроля над анимацией можно использовать псевдоэлементы `::view-transition-old` и `::view-transition-new`. Они позволяют стилизовать старое и новое состояния элемента соответственно.

```css
::view-transition-old(root),
::view-transition-new(root) {
  animation-duration: 0.8s;
  animation-timing-function: ease-in-out;
}

::view-transition-old(root) {
  animation-name: fade-out;
}

::view-transition-new(root) {
  animation-name: fade-in;
}

@keyframes fade-in {
  from { opacity: 0; }
  to { opacity: 1; }
}

@keyframes fade-out {
  from { opacity: 1; }
  to { opacity: 0; }
}
```

Этот CSS код задает анимацию плавного появления и исчезновения для всей страницы (root).

### Жизненный пример

Многие современные сайты и приложения используют подобные переходы для улучшения пользовательского опыта. Например:

*   **SPA (Single Page Applications):**  Фреймворки, такие как React, Vue, и Angular, могут интегрировать View Transitions API для создания плавных переходов между страницами без полной перезагрузки.
*   **E-commerce сайты:**  При переходе от списка товаров к детальной странице товара, можно использовать View Transitions API для анимированного "перемещения" изображения товара, создавая ощущение связи между двумя страницами.
*   **Мобильные приложения (PWA):** PWA, стремящиеся к "нативному" опыту, могут использовать View Transitions API для имитации переходов между экранами, характерных для мобильных приложений.

### Ключевые моменты

*   `document.startViewTransition()` – основной метод для запуска перехода.
*   Callback-функция в `startViewTransition()` должна содержать изменения DOM.
*   `::view-transition-old` и `::view-transition-new` позволяют стилизовать старое и новое состояния элементов.
*   API обеспечивает плавные переходы между состояниями, улучшая UX.
*   View Transitions API может быть использован для создания более интерактивных и "живых" веб-приложений.



## Интерактивный пример

<Sandpack
  template="vanilla"
  files={{
    "/index.html": `<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>View Transitions API Example</title>
  <link rel="stylesheet" href="/styles.css">
</head>
<body>
  <div class="container">
    <h1>View Transitions API</h1>

    <div class="item-list">
      <div class="item" data-item-id="1">
        <img src="https://via.placeholder.com/150" alt="Item 1">
        <p>Товар 1</p>
        <button class="view-details" data-item-id="1">Подробнее</button>
      </div>
      <div class="item" data-item-id="2">
        <img src="https://via.placeholder.com/150" alt="Item 2">
        <p>Товар 2</p>
        <button class="view-details" data-item-id="2">Подробнее</button>
      </div>
    </div>

    <div id="details-container" class="details-container hidden">
      <button id="back-button">Назад</button>
      <div id="details-content"></div>
    </div>
  </div>

  <script src="/index.js"><\/script>
</body>
</html>
`,
    "/styles.css": `body {
  font-family: sans-serif;
  background-color: #222;
  color: #fff;
  margin: 0;
  padding: 0;
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 100vh;
}

.container {
  padding: 20px;
  background-color: #333;
  border-radius: 8px;
  width: 80%;
  max-width: 800px;
}

h1 {
  text-align: center;
  margin-bottom: 20px;
}

.item-list {
  display: flex;
  gap: 20px;
  justify-content: space-around;
}

.item {
  text-align: center;
}

.item img {
  width: 150px;
  height: 150px;
  object-fit: cover;
  border-radius: 8px;
  margin-bottom: 10px;
}

.view-details {
  padding: 8px 16px;
  background-color: #4CAF50;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

.details-container {
  margin-top: 20px;
  padding: 20px;
  background-color: #444;
  border-radius: 8px;
}

.hidden {
  display: none;
}

#back-button {
  padding: 8px 16px;
  background-color: #f44336;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  margin-bottom: 10px;
}

/* Стили для View Transitions */
::view-transition-old(item-image),
::view-transition-new(item-image) {
  object-fit: cover;
  width: 400px;
  height: 300px;
  border-radius: 8px;
}

::view-transition-old(back-button),
::view-transition-new(back-button) {
  width: auto;
}
`,
    "/index.js": `document.addEventListener('DOMContentLoaded', () => {
  const itemList = document.querySelector('.item-list');
  const detailsContainer = document.getElementById('details-container');
  const detailsContent = document.getElementById('details-content');
  const backButton = document.getElementById('back-button');

  // Функция для отображения деталей товара
  function showDetails(itemId) {
    const itemData = {
      1: { name: 'Товар 1', description: 'Описание товара 1. Очень интересный товар!', imageUrl: 'https://via.placeholder.com/400x300' },
      2: { name: 'Товар 2', description: 'Описание товара 2. Еще более захватывающий товар!', imageUrl: 'https://via.placeholder.com/400x300' },
    };

    const item = itemData[itemId];

    if (item) {
      // Запускаем View Transition
      document.startViewTransition(() => {
        // Обновляем содержимое details-container
        detailsContent.innerHTML = \`
          <h2>\${item.name}</h2>
          <img src="\${item.imageUrl}" alt="\${item.name}" style="view-transition-name: item-image;">
          <p>\${item.description}</p>
        \`;

        // Показываем details-container и скрываем item-list
        itemList.classList.add('hidden');
        detailsContainer.classList.remove('hidden');

        // Возвращаем состояние DOM после изменений
        return;
      });
    }
  }

  // Функция для возврата к списку товаров
  function goBack() {
    document.startViewTransition(() => {
      // Скрываем details-container и показываем item-list
      detailsContainer.classList.add('hidden');
      itemList.classList.remove('hidden');

      // Очищаем содержимое details-container
      detailsContent.innerHTML = '';

      // Возвращаем состояние DOM после изменений
      return;
    });
  }

  // Обработчики событий
  itemList.addEventListener('click', (event) => {
    if (event.target.classList.contains('view-details')) {
      const itemId = event.target.dataset.itemId;
      showDetails(itemId);
    }
  });

  backButton.addEventListener('click', goBack);
});
`
  }}
  options={{
    showNavigator: false,
    showLineNumbers: true,
    editorHeight: 400
  }}
/>
