![Animation Performance](/lessons/css-animation-perf.png)

## CSS: Производительность анимаций (will-change, GPU)

Анимации делают веб-сайты более привлекательными, но неправильная их реализация может существенно снизить производительность. В этом уроке мы рассмотрим, как оптимизировать CSS-анимации, используя свойство `will-change` и задействуя графический процессор (GPU).

### Проблема производительности

Когда браузер анимирует элемент, ему приходится пересчитывать стили и перерисовывать его на каждом кадре анимации. Это может быть ресурсоемким процессом, особенно если анимируется сложное свойство или большое количество элементов. Без оптимизации, анимация может стать "дерганой" и неприятной для пользователя.

### `will-change`: Подсказка для браузера

Свойство `will-change` позволяет сообщить браузеру, какие свойства элемента будут анимироваться. Это дает браузеру возможность заранее подготовиться к изменениям и оптимизировать процесс анимации.

Пример:

```css
.element {
  transition: transform 0.3s ease-in-out;
}

.element:hover {
  transform: translateX(100px);
}

.element:hover {
  will-change: transform; /* Сообщаем браузеру, что будет изменяться transform */
}
```

В этом примере, при наведении на элемент `.element`, он будет смещаться вправо. Добавление `will-change: transform;` позволяет браузеру заранее выделить необходимые ресурсы для плавной анимации `transform`.

**Важно:** Не злоупотребляйте `will-change`. Используйте его только для элементов, которые действительно анимируются. Чрезмерное использование может привести к повышенному потреблению памяти и даже ухудшению производительности.

### GPU: Аппаратное ускорение

Современные браузеры используют графический процессор (GPU) для ускорения определенных операций, включая CSS-анимации. Однако, не все CSS-свойства могут быть ускорены GPU.

Свойства, которые обычно ускоряются GPU:

*   `transform` (translate, rotate, scale)
*   `opacity`

Использование этих свойств для анимации, как правило, обеспечивает более плавную и производительную анимацию, чем, например, анимация `top`, `left`, `width` или `height`.

Пример:

```css
.element {
  transition: transform 0.3s ease-in-out;
}

.element:hover {
  transform: translateX(100px) rotate(45deg); /* Используем transform для анимации */
}
```

Вместо изменения `left` или `top` для перемещения элемента, мы используем `translateX`. Это позволяет браузеру задействовать GPU для анимации, что значительно повышает производительность.

### Жизненный пример

Многие современные веб-сайты и фреймворки активно используют `will-change` и GPU-ускоренные свойства для создания плавных и интерактивных пользовательских интерфейсов.

Например, при создании параллакс-эффекта (когда фон движется с другой скоростью, чем основной контент), часто используют `transform: translateZ(0)` в сочетании с `will-change: transform` для плавного перемещения фоновых изображений. Библиотеки анимаций, такие как GreenSock (GSAP), также активно используют эти методы для оптимизации производительности анимаций.

React и Vue.js фреймворки могут динамически добавлять и удалять классы, содержащие `will-change`, в зависимости от состояния компонента, чтобы оптимизировать рендеринг.

### Ключевые моменты

*   `will-change` подсказывает браузеру, какие свойства будут анимироваться.
*   Используйте `will-change` только для анимируемых элементов.
*   `transform` и `opacity` обычно ускоряются GPU.
*   Избегайте анимации свойств, которые не ускоряются GPU (например, `top`, `left`).
*   Используйте инструменты разработчика браузера для анализа производительности анимаций.
*   Тестируйте анимации на разных устройствах и браузерах.

### Практика

<Playground 
  html={`<div class="perf-demo">
  <div class="comparison">
    <div class="column bad">
      <h3>❌ Медленно (без оптимизации)</h3>
      <div class="box-container">
        <div class="box bad-box">left/top</div>
      </div>
      <p>Анимация: left, width, height</p>
      <p class="warning">Вызывает reflow!</p>
    </div>
    
    <div class="column good">
      <h3>✅ Быстро (оптимизировано)</h3>
      <div class="box-container">
        <div class="box good-box">transform</div>
      </div>
      <p>Анимация: transform, opacity</p>
      <p class="success">GPU-ускорение!</p>
    </div>
  </div>
  
  <div class="info-panel">
    <h4>will-change пример:</h4>
    <div class="will-change-demo">
      <div class="hover-box">
        Наведи на меня
      </div>
    </div>
    <code>will-change: transform;</code>
  </div>
</div>`}
  css={`.perf-demo {
  padding: 20px;
  font-family: sans-serif;
}

.comparison {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  gap: 30px;
  margin-bottom: 30px;
}

.column {
  background: #f5f5f5;
  padding: 20px;
  border-radius: 10px;
}

h3 {
  margin: 0 0 20px 0;
  text-align: center;
}

.box-container {
  height: 150px;
  background: white;
  border-radius: 8px;
  padding: 20px;
  margin-bottom: 15px;
  position: relative;
  overflow: hidden;
}

.box {
  width: 80px;
  height: 80px;
  border-radius: 8px;
  color: white;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: bold;
  font-size: 14px;
  position: absolute;
}

/* Плохой способ - анимация layout свойств */
.bad-box {
  background: #e74c3c;
  animation: badMove 3s ease-in-out infinite;
}

@keyframes badMove {
  0%, 100% { left: 0; width: 80px; }
  50% { left: 150px; width: 100px; }
}

/* Хороший способ - transform и opacity */
.good-box {
  background: #2ecc71;
  animation: goodMove 3s ease-in-out infinite;
  will-change: transform;
}

@keyframes goodMove {
  0%, 100% { 
    transform: translateX(0) scale(1); 
    opacity: 1;
  }
  50% { 
    transform: translateX(150px) scale(1.25); 
    opacity: 0.8;
  }
}

p {
  margin: 5px 0;
  font-size: 14px;
  color: #666;
}

.warning {
  color: #e74c3c;
  font-weight: bold;
}

.success {
  color: #2ecc71;
  font-weight: bold;
}

.info-panel {
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
  padding: 20px;
  border-radius: 10px;
  text-align: center;
}

h4 {
  margin: 0 0 15px 0;
}

.will-change-demo {
  margin: 15px 0;
}

.hover-box {
  display: inline-block;
  background: rgba(255,255,255,0.2);
  padding: 20px 40px;
  border-radius: 8px;
  cursor: pointer;
  transition: transform 0.3s ease;
  will-change: transform;
}

.hover-box:hover {
  transform: translateY(-10px) scale(1.1);
}

code {
  background: rgba(0,0,0,0.2);
  padding: 5px 10px;
  border-radius: 5px;
  font-family: monospace;
}`}
  js={``}
/>
