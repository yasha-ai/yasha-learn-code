## React: Формы под контролем

Формы — это неотъемлемая часть любого интерактивного веб-приложения. В React подход к работе с формами отличается от традиционного HTML, акцентируя внимание на управляемых компонентах.

### Концепция: Управляемые Компоненты

В React состояние формы обычно управляется самим React. Это означает, что данные формы хранятся в состоянии компонента и обновляются через обработчики событий. Такие компоненты называются *управляемыми* (controlled components).

Преимущества управляемых компонентов:
*   Легкая валидация в реальном времени.
*   Мгновенная обратная связь пользователю.
*   Простая интеграция со сторонними библиотеками.

### Базовый Пример: Текстовое Поле

Начнем с простого текстового поля. Мы будем использовать `useState` для хранения значения поля и `onChange` для его обновления.

```jsx
import React, { useState } from 'react';

function SimpleForm() {
  // 1. Создаем состояние для значения поля ввода
  const [name, setName] = useState('');

  // 2. Обработчик изменения поля ввода
  const handleChange = (e) => {
    setName(e.target.value); // Обновляем состояние на основе нового значения
  };

  // 3. Обработчик отправки формы
  const handleSubmit = (e) => {
    e.preventDefault(); // Предотвращаем стандартное поведение браузера (перезагрузку)
    console.log('Отправлено имя:', name);
    // Здесь можно отправить данные на сервер или обработать их
  };

  return (
    <form onSubmit={handleSubmit}>
      <label>
        Имя:
        {/* 4. Поле ввода: value привязано к состоянию, onChange обновляет состояние */}
        <input type="text" value={name} onChange={handleChange} />
      </label>
      <button type="submit">Отправить</button>
    </form>
  );
}
```
*В этом примере `<input>` является управляемым, так как его значение определяется состоянием `name`.*

### Hooks и Множественные Поля

Для форм с несколькими полями удобно использовать один объект состояния.

```jsx
import React, { useState } from 'react';

function MultiFieldForm() {
  const [formData, setFormData] = useState({
    username: '',
    email: '',
    password: ''
  });

  const handleChange = (e) => {
    // Деструктурируем name и value из target элемента
    const { name, value } = e.target;
    // Обновляем только то поле, которое изменилось
    setFormData(prevData => ({
      ...prevData,
      [name]: value // Используем вычисляемое имя свойства
    }));
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    console.log('Отправленные данные:', formData);
  };

  return (
    <form onSubmit={handleSubmit}>
      <input type="text" name="username" value={formData.username} onChange={handleChange} placeholder="Имя пользователя" />
      <input type="email" name="email" value={formData.email} onChange={handleChange} placeholder="Email" />
      <input type="password" name="password" value={formData.password} onChange={handleChange} placeholder="Пароль" />
      <button type="submit">Зарегистрироваться</button>
    </form>
  );
}
```
*Важно: атрибут `name` должен соответствовать ключу в объекте состояния.*

### Типы Полей: Select, Checkbox, Radio

Принципы управляемых компонентов применимы и к другим типам полей.

```jsx
import React, { useState } from 'react';

function OtherFieldsForm() {
  const [fruit, setFruit] = useState('apple'); // Для <select>
  const [isAgreed, setIsAgreed] = useState(false); // Для <checkbox>
  const [gender, setGender] = useState('male'); // Для <radio>

  const handleFruitChange = (e) => setFruit(e.target.value);
  const handleAgreementChange = (e) => setIsAgreed(e.target.checked); // Для чекбокса используем .checked
  const handleGenderChange = (e) => setGender(e.target.value);

  return (
    <form>
      <select value={fruit} onChange={handleFruitChange}>
        <option value="apple">Яблоко</option>
        <option value="banana">Банан</option>
        <option value="orange">Апельсин</option>
      </select>
      <label>
        <input type="checkbox" checked={isAgreed} onChange={handleAgreementChange} />
        Согласен с условиями
      </label>
      <div>
        <label><input type="radio" value="male" checked={gender === 'male'} onChange={handleGenderChange} name="gender" /> Мужской</label>
        <label><input type="radio" value="female" checked={gender === 'female'} onChange={handleGenderChange} name="gender" /> Женский</label>
      </div>
    </form>
  );
}
```

### Оптимизация

Для сложных форм с множеством полей или когда обработчики передаются дочерним компонентам, можно использовать `useCallback` для мемоизации обработчиков событий и предотвращения лишних ре-рендеров.

```jsx
import React, { useState, useCallback } from 'react';

function OptimizedForm() {
  const [value, setValue] = useState('');

  // Обработчик мемоизируется и не будет пересоздаваться при каждом ре-рендере,
  // если зависимости (в данном случае []) не изменились.
  const handleChange = useCallback((e) => {
    setValue(e.target.value);
  }, []); // Пустой массив зависимостей означает, что функция создается один раз

  return (
    <input type="text" value={value} onChange={handleChange} />
  );
}
```
*Для большинства простых форм `useCallback` не обязателен, но полезен в оптимизации производительности.*

### Типичные Ошибки

1.  **Забыли `e.preventDefault()` в `onSubmit`**: Приводит к перезагрузке страницы.
2.  **Не указали `name` для полей при использовании объекта состояния**: Обработчик `handleChange` не сможет правильно обновить состояние.
3.  **Неправильно обновили состояние для чекбоксов**: Использовали `e.target.value` вместо `e.target.checked`.
4.  **`value` поля не привязан к состоянию**: Поле становится *неуправляемым* и не будет реагировать на программные изменения. React выдаст предупреждение.
5.  **Пытаетесь установить `value` для `input type="file"`**: Это поле всегда неуправляемое. Используйте `useRef` для доступа к файлам.

### Практика: Форма обратной связи

Создайте форму обратной связи с полями: имя, email, тема (dropdown), сообщение (textarea) и чекбокс "Подписаться на рассылку".

```jsx
// Домашнее задание: Создайте компонент ContactForm
// В нем должны быть:
// - Состояние для имени, email, темы, сообщения, подписки.
// - Обработчик handleChange для всех полей.
// - Обработчик handleSubmit, который выводит все данные в консоль.
// - Используйте <select>, <textarea>, <input type="checkbox">.
```