## React: Props и State – Основы динамики компонентов

В основе любого интерактивного React-приложения лежат два ключевых понятия: `props` (сокращение от "properties", свойства) и `state` (состояние). Именно они позволяют компонентам обмениваться данными и реагировать на действия пользователя, делая интерфейс динамичным и отзывчивым.

### Концепция: Props vs. State

*   **Props (Свойства):** Это механизм для передачи данных **сверху вниз** от родительского компонента к дочернему. Думайте о `props` как об аргументах функции: они неизменяемы для дочернего компонента, который их получает. Компонент не может изменить свои собственные `props`. Если данные должны измениться, это должен сделать родительский компонент, который их передает.

*   **State (Состояние):** Это данные, которые **управляются самим компонентом**. В отличие от `props`, `state` является изменяемым, и когда он меняется, React автоматически перерисовывает (re-renders) компонент. `State` позволяет компонентам быть интерактивными и хранить информацию, которая может меняться со временем (например, значение в поле ввода, текущий выбор в списке, видимость модального окна).

### Базовый пример Props

Давайте посмотрим, как `props` передаются и используются.

```jsx
// Родительский компонент, который передает props
function App() {
  return (
    <div>
      <WelcomeMessage name="Мир React" />
      <WelcomeMessage name="Разработчик" />
    </div>
  );
}

// Дочерний компонент, который принимает и использует props
function WelcomeMessage({ name }) { // Деструктуризация props для удобства
  return <h1>Привет, {name}!</h1>;
}
```
В этом примере `App` передает свойство `name` компоненту `WelcomeMessage`. `WelcomeMessage` получает `name` как часть своего объекта `props` и отображает его.

### Управление состоянием с помощью Hooks (`useState`)

Для управления состоянием в функциональных компонентах React предоставляет хук `useState`.

```jsx
import React, { useState } from 'react';

function Counter() {
  // Объявляем переменную состояния 'count' и функцию 'setCount' для ее обновления.
  // Начальное значение 'count' установлено на 0.
  const [count, setCount] = useState(0);

  // Функция для увеличения счетчика
  const increment = () => {
    setCount(count + 1); // Обновляем состояние
  };

  // Функция для уменьшения счетчика, используя функцию обратного вызова
  // для доступа к предыдущему состоянию. Это безопаснее при асинхронных обновлениях.
  const decrement = () => {
    setCount(prevCount => prevCount - 1);
  };

  return (
    <div>
      <p>Счетчик: {count}</p>
      <button onClick={increment}>Увеличить</button>
      <button onClick={decrement}>Уменьшить</button>
    </div>
  );
}
```
Здесь `count` — это текущее значение состояния, а `setCount` — функция, которая позволяет его изменять. Когда `setCount` вызывается, React перерисовывает компонент `Counter` с новым значением `count`.

### Комбинированный пример (Props + State)

Часто компоненты используют и `props`, и `state` одновременно. `props` могут служить для передачи начальных значений, а `state` — для их последующего изменения внутри компонента.

```jsx
import React, { useState } from 'react';

function ThemeSwitcher({ initialTheme = 'light' }) {
  // Используем initialTheme из props как начальное состояние
  const [theme, setTheme] = useState(initialTheme);

  const toggleTheme = () => {
    setTheme(prevTheme => (prevTheme === 'light' ? 'dark' : 'light'));
  };

  const style = {
    background: theme === 'light' ? '#f0f0f0' : '#333',
    color: theme === 'light' ? '#333' : '#f0f0f0',
    padding: '20px',
    borderRadius: '8px'
  };

  return (
    <div style={style}>
      <h3>Текущая тема: {theme}</h3>
      <button onClick={toggleTheme}>Переключить тему</button>
    </div>
  );
}

// Использование в родительском компоненте:
// <ThemeSwitcher initialTheme="dark" />
// <ThemeSwitcher /> // Будет использована тема по умолчанию 'light'
```

### Оптимизация с Props и State

*   **`React.memo` для пропсов:** Если дочерний компонент всегда получает одни и те же `props` и его логика не меняется, его можно обернуть в `React.memo` для предотвращения ненужных ре-рендеров.

    ```jsx
    import React, { useState, memo } from 'react';

    // Дочерний компонент, который будет ре-рендериться только при изменении props.name
    const DisplayGreeting = memo(function DisplayGreeting({ name }) {
      console.log(`DisplayGreeting ре-рендерится для ${name}`);
      return <p>Привет, {name}!</p>;
    });

    function OptimizingParent() {
      const [count, setCount] = useState(0);
      const [userName, setUserName] = useState('Алекс');

      return (
        <div>
          <button onClick={() => setCount(count + 1)}>
            Счетчик родителя: {count} {/* Изменение этого state не ре-рендерит DisplayGreeting */}
          </button>
          <DisplayGreeting name={userName} />
          <button onClick={() => setUserName(userName === 'Алекс' ? 'Мария' : 'Алекс')}>
            Сменить имя
          </button>
        </div>
      );
    }
    ```
    `DisplayGreeting` не будет перерисовываться, когда меняется `count`, потому что его пропсы (`name`) не изменились.
*   **Уникальный `key` для списков:** При отображении списков элементов, генерируемых из массива, всегда используйте уникальный `key` пропс. Это помогает React эффективно обновлять DOM.

    ```jsx
    <ul>
      {items.map(item => (
        <li key={item.id}>{item.text}</li> // item.id - уникальный идентификатор
      ))}
    </ul>
    ```

### Типичные ошибки

1.  **Прямая мутация состояния:** Никогда не изменяйте объекты или массивы, хранящиеся в состоянии, напрямую. Вместо этого всегда создавайте новую копию.

    ```jsx
    function BadExample() {
      const [items, setItems] = useState(['Яблоко']);

      const addItemBad = () => {
        // ОШИБКА: Прямая мутация! React может не увидеть изменения.
        // items.push('Банан');
        // setItems(items);

        // ПРАВИЛЬНО: Создание нового массива
        setItems([...items, 'Банан']);
      };
      // ...
    }
    ```

2.  **Неправильное обновление состояния при зависимости от предыдущего:** При обновлении состояния, которое зависит от его предыдущего значения, используйте функциональную форму `setState`.

    ```jsx
    // НЕПРАВИЛЬНО:
    // setCount(count + 1); // Может вызвать проблемы при асинхронных обновлениях или в batching

    // ПРАВИЛЬНО:
    // setCount(prevCount => prevCount + 1); // Гарантирует использование актуального предыдущего значения
    ```

3.  **Использование `index` в качестве `key` для списков:** Если элементы списка могут быть переупорядочены, добавлены или удалены, использование `index` в качестве `key` может привести к проблемам с производительностью и некорректному отображению. Всегда используйте стабильный, уникальный ID.

### Практика: Компонент "Список Задач"

Создайте компонент `TodoList`, который принимает массив начальных задач через `props` и позволяет добавлять новые задачи, а также удалять существующие, используя `state`.

```jsx
import React, { useState } from 'react';

function TodoList({ initialTodos = [] }) {
  // Состояние для списка задач (каждая задача - объект с id и text)
  const [todos, setTodos] = useState(initialTodos);
  // Состояние для текста новой задачи в поле ввода
  const [newTodoText, setNewTodoText] = useState('');

  const handleAddTodo = () => {
    if (newTodoText.trim()) { // Проверяем, что текст не пустой
      const newTodo = {
        id: Date.now(), // Простой уникальный ID
        text: newTodoText.trim()
      };
      setTodos([...todos, newTodo]); // Добавляем новую задачу, создавая новый массив
      setNewTodoText(''); // Очищаем поле ввода
    }
  };

  const handleRemoveTodo = (idToRemove) => {
    // Фильтруем список, удаляя задачу с указанным ID
    setTodos(todos.filter(todo => todo.id !== idToRemove));
  };

  return (
    <div style={{ border: '1px solid #ccc', padding: '15px', borderRadius: '5px', maxWidth: '400px', margin: '20px auto' }}>
      <h2>Мой список задач</h2>
      <input
        type="text"
        value={newTodoText}
        onChange={(e) => setNewTodoText(e.target.value)}
        placeholder="Что нужно сделать?"
        style={{ marginRight: '10px', padding: '8px', border: '1px solid #ddd' }}
      />
      <button onClick={handleAddTodo} style={{ padding: '8px 12px', background: '#007bff', color: '#fff', border: 'none', borderRadius: '4px', cursor: 'pointer' }}>
        Добавить
      </button>

      <ul style={{ listStyle: 'none', padding: 0 }}>
        {todos.map(todo => (
          <li key={todo.id} style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', padding: '8px 0', borderBottom: '1px dotted #eee' }}>
            <span>{todo.text}</span>
            <button onClick={() => handleRemoveTodo(todo.id)} style={{ background: '#dc3545', color: '#fff', border: 'none', borderRadius: '4px', padding: '5px 10px', cursor: 'pointer' }}>
              Удалить
            </button>
          </li>
        ))}
      </ul>
      {todos.length === 0 && <p style={{ textAlign: 'center', color: '#888' }}>Задач нет!</p>}
    </div>
  );
}

// Пример использования:
// <TodoList initialTodos={[{ id: 1, text: 'Купить продукты' }, { id: 2, text: 'Позвонить маме' }]} />
```