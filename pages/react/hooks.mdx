## React: Hooks (useState, useEffect)

Хуки (Hooks) — это фундаментальное изменение в разработке React-приложений, представленное в версии 16.8. Они позволяют использовать состояние и другие возможности React в функциональных компонентах, полностью отказавшись от классовых компонентов.

### 1. Концепция: Зачем нужны Хуки?

До появления хуков, для управления состоянием и выполнения побочных эффектов требовались классовые компоненты, что часто приводило к проблемам:
*   Сложность работы с `this`.
*   Логика, связанная с одной функцией (например, загрузка данных), могла быть разбросана по разным методам жизненного цикла (`componentDidMount`, `componentDidUpdate`).
*   Сложности с переиспользованием логики состояния между компонентами.

Хуки решают эти проблемы, предлагая более простой и функциональный подход. Они делают код более читаемым, модульным и легким для переиспользования.

### 2. useState: Состояние в Функциональных Компонентах

Хук `useState` позволяет добавлять состояние React к функциональным компонентам. Он возвращает пару: текущее значение состояния и функцию для его обновления.

```typescript jsx
import React, { useState } from 'react';

function Counter() {
  // Объявляем новую переменную состояния "count"
  // Начальное значение состояния - 0
  const [count, setCount] = useState(0); 

  // Пример 1: Базовый счетчик
  return (
    <div>
      <p>Вы кликнули {count} раз</p>
      <button onClick={() => setCount(count + 1)}>
        Кликни меня
      </button>
    </div>
  );
}
```

**Функциональное обновление состояния:** При обновлении состояния, которое зависит от предыдущего значения, рекомендуется использовать функциональную форму `setCount`:

```typescript jsx
import React, { useState } from 'react';

function FunctionalCounter() {
  const [count, setCount] = useState(0);

  // Пример 2: Функциональное обновление
  // Гарантирует, что вы работаете с самым актуальным значением count
  const increment = () => {
    setCount(prevCount => prevCount + 1);
  };

  return <button onClick={increment}>Увеличить: {count}</button>;
}
```

**Объекты и массивы в состоянии:** При хранении объектов или массивов в `useState` и их обновлении, всегда создавайте новую копию объекта/массива.

```typescript jsx
import React, { useState } from 'react';

function UserProfileEditor() {
  const [user, setUser] = useState({ name: 'Иван', age: 30 });

  // Пример 3: Обновление объекта в состоянии
  const handleChangeName = () => {
    // Важно: создаем новый объект с помощью spread-оператора
    setUser(prevUser => ({ ...prevUser, name: 'Петр' }));
  };

  return (
    <div>
      <p>Имя: {user.name}, Возраст: {user.age}</p>
      <button onClick={handleChangeName}>Изменить имя</button>
    </div>
  );
}
```

### 3. useEffect: Побочные Эффекты

Хук `useEffect` позволяет выполнять побочные эффекты (загрузка данных, подписки, ручные изменения DOM) в функциональных компонентах. Он вызывается после каждого рендера, если не указаны зависимости.

```typescript jsx
import React, { useState, useEffect } from 'react';

function DataFetcher() {
  const [data, setData] = useState(null);
  const [id, setId] = useState(1);

  // Пример 4: useEffect без массива зависимостей (выполняется при каждом рендере)
  // Используйте осторожно, чтобы избежать бесконечных циклов или ненужных операций
  useEffect(() => {
    console.log('Компонент был перерисован или смонтирован.');
  });

  // Пример 5: useEffect с пустым массивом зависимостей [] (выполняется только один раз после монтирования)
  // Аналогично componentDidMount
  useEffect(() => {
    console.log('Компонент смонтирован, загружаем данные в первый раз...');
    fetch(`https://jsonplaceholder.typicode.com/todos/${id}`)
      .then(response => response.json())
      .then(json => setData(json));
  }, []); // Пустой массив означает "выполнить один раз при монтировании"

  // Пример 6: useEffect с зависимостью [id] (выполняется при изменении id)
  // Аналогично componentDidUpdate для конкретного props/state
  useEffect(() => {
    console.log(`ID изменился на ${id}, загружаем новые данные...`);
    // Это загрузит данные только тогда, когда 'id' изменится
    fetch(`https://jsonplaceholder.typicode.com/todos/${id}`)
      .then(response => response.json())
      .then(json => setData(json));
  }, [id]); // Эффект перезапустится, когда id изменится

  // Пример 7: Функция очистки (cleanup function) (аналог componentWillUnmount)
  // Возвращаем функцию, которая будет вызвана перед следующим запуском эффекта
  // или при размонтировании компонента.
  useEffect(() => {
    const interval = setInterval(() => {
      console.log('Интервал работает...');
    }, 1000);

    return () => { // Функция очистки
      clearInterval(interval);
      console.log('Интервал очищен.');
    };
  }, []); // Пустой массив, интервал запускается один раз и очищается при размонтировании
  
  return (
    <div>
      <h3>Загрузка данных</h3>
      <p>Текущий ID: {id}</p>
      <button onClick={() => setId(prevId => prevId + 1)}>Следующий ID</button>
      {data ? <pre>{JSON.stringify(data, null, 2)}</pre> : <p>Загрузка...</p>}
    </div>
  );
}
```

### 4. Оптимизация с useEffect

Ключ к оптимизации `useEffect` — это правильное использование массива зависимостей.
*   Если эффект не зависит от пропсов или состояния компонента и должен выполниться только один раз при монтировании, используйте пустой массив `[]`.
*   Включайте все значения из области видимости компонента (props, state, функции), которые используются внутри `useEffect` и могут изменяться, в массив зависимостей. React linting rules (ESLint) помогут вам с этим.

### 5. Типичные ошибки

*   **useState:**
    *   **Прямое изменение состояния:** `user.name = 'Новое имя';` — **НЕПРАВИЛЬНО**. Всегда используйте функцию `setUser` и создавайте новый объект/массив.
    *   **Забыли функциональное обновление:** Если `setCount(count + 1)` используется в обработчике, который может быть вызван несколько раз подряд до перерендера (например, в цикле), `count` может быть устаревшим. `setCount(prevCount => prevCount + 1)` предотвращает это.
*   **useEffect:**
    *   **Неправильный массив зависимостей:**
        *   **Пропуск зависимостей:** Если переменная используется внутри эффекта, но не указана в массиве зависимостей, эффект будет использовать устаревшее значение этой переменной (замыкание). Это приводит к ошибкам.
        *   **Избыточные зависимости:** Включение в зависимости значений, которые не меняются, или функций, которые ресоздаются при каждом рендере (без `useCallback`), может привести к ненужным перезапускам эффекта.
    *   **Забыли функцию очистки:** Для подписок, таймеров, внешних слушателей событий, если не вернуть функцию очистки, это приведет к утечкам памяти.

### 6. Практика

Попробуйте создать компонент, который:
1.  Отображает два счетчика: один обновляется обычным способом, другой — функциональным обновлением.
2.  Использует `useEffect` для вывода сообщения в консоль при монтировании компонента и при каждом изменении одного из счетчиков.
3.  Использует `useEffect` с функцией очистки для установки и очистки заголовка документа (`document.title`) на основе значения счетчика.