## React: Context API

### Что такое Context API?

Context API в React — это мощный механизм, который позволяет передавать данные через дерево компонентов без необходимости вручную "пробуривать" пропсы (prop drilling) через каждый уровень. Это идеальное решение для передачи "глобальных" данных, доступных многим компонентам приложения.

**Типичные сценарии использования:**
*   Тема оформления (светлая/темная)
*   Данные аутентификации пользователя
*   Выбранный язык
*   Общие настройки приложения

**Когда НЕ использовать:**
*   Для локального состояния компонента.
*   Когда данные изменяются очень часто и затрагивают лишь небольшую часть дерева, так как все потребители контекста будут перерисовываться при его изменении.
*   Как полную замену сложным стейт-менеджерам (Redux, Zustand), если у вас очень большое и сложное глобальное состояние с множеством зависимостей и сайд-эффектов. Context API — это инструмент для *передачи* состояния, а не для его сложного *управления*.

### Базовый Пример: Создание и Предоставление Контекста

Для использования Context API вам необходимо создать контекст с помощью `React.createContext()`. Этот метод возвращает объект с компонентом `Provider`, который будет "предоставлять" данные.

```jsx
// src/contexts/ThemeContext.js
import React from 'react';

// 1. Создание контекста с дефолтным значением.
// Дефолтное значение используется, если компонент-потребитель
// рендерится без соответствующего Provider'а выше в дереве.
export const ThemeContext = React.createContext({
  theme: 'light',
  toggleTheme: () => {}, // Пустая функция для дефолта
});

// 2. Создание компонента-провайдера для управления состоянием и его предоставления.
export const ThemeProvider = ({ children }) => {
  const [theme, setTheme] = React.useState('light');

  const toggleTheme = () => {
    setTheme(prevTheme => (prevTheme === 'light' ? 'dark' : 'light'));
  };

  // Важно: useMemo гарантирует, что объект value не будет
  // создаваться заново при каждом рендере ThemeProvider,
  // предотвращая ненужные перерисовки потребителей.
  const contextValue = React.useMemo(() => ({ theme, toggleTheme }), [theme]);

  return (
    <ThemeContext.Provider value={contextValue}>
      {children}
    </ThemeContext.Provider>
  );
};
```

Теперь, чтобы сделать контекст доступным, оберните компоненты в `ThemeProvider`:

```jsx
// src/App.js
import React from 'react';
import { ThemeProvider } from './contexts/ThemeContext';
import Header from './components/Header'; // Компонент, который будет использовать тему
import Footer from './components/Footer';

function App() {
  return (
    <ThemeProvider>
      {/* Все компоненты внутри ThemeProvider имеют доступ к ThemeContext */}
      <Header />
      <main style={{ padding: '20px' }}>
        <p>Содержимое страницы...</p>
      </main>
      <Footer />
    </ThemeProvider>
  );
}

export default App;
```

### Современный Подход: Хук `useContext`

Для потребления контекста в функциональных компонентах используется хук `useContext`. Это чистый и современный способ получить доступ к значению контекста.

```jsx
// src/components/Header.js
import React from 'react';
import { ThemeContext } from '../contexts/ThemeContext'; // Импортируем сам контекст

function Header() {
  // Используем useContext для получения значения из ThemeContext
  const { theme, toggleTheme } = React.useContext(ThemeContext);

  const headerStyle = {
    background: theme === 'dark' ? '#333' : '#eee',
    color: theme === 'dark' ? '#eee' : '#333',
    padding: '15px',
    textAlign: 'center',
  };

  return (
    <header style={headerStyle}>
      <h1>Мое Приложение</h1>
      <button onClick={toggleTheme}>
        Переключить тему на {theme === 'light' ? 'темную' : 'светлую'}
      </button>
      <DeeplyNestedComponent /> {/* Компонент, находящийся глубоко в дереве */}
    </header>
  );
}

// src/components/DeeplyNestedComponent.js
import { ThemeContext } from '../contexts/ThemeContext';

function DeeplyNestedComponent() {
  const { theme } = React.useContext(ThemeContext);
  return (
    <p style={{ marginTop: '10px', fontSize: '0.8em' }}>
      Глубоко вложенный компонент, текущая тема: {theme}
    </p>
  );
}

export default Header;
```

### Оптимизация Производительности

Главная особенность Context API — это то, что при изменении значения `value` провайдера, *все* компоненты, использующие `useContext` для этого контекста, будут перерисовываться.

**1. Мемоизация значения провайдера (`useMemo`):**
Как показано в `ThemeProvider`, `useMemo` предотвращает создание нового объекта `value` на каждом рендере, если зависимости (в нашем случае `theme`) не изменились. Это критично для производительности.

**2. Разделение контекстов:**
Если ваш "глобальный" контекст содержит несколько логически независимых частей состояния, разделите его на несколько меньших контекстов.

```jsx
// src/contexts/AuthContext.js
import React from 'react';

export const AuthContext = React.createContext({
  user: null,
  login: () => {},
  logout: () => {},
});

export const AuthProvider = ({ children }) => {
  const [user, setUser] = React.useState(null); // Например, { id: 1, name: 'Alice' }

  const login = (userData) => setUser(userData);
  const logout = () => setUser(null);

  const authValue = React.useMemo(() => ({ user, login, logout }), [user]);

  return (
    <AuthContext.Provider value={authValue}>
      {children}
    </AuthContext.Provider>
  );
};
```
Теперь, если изменится только тема, компоненты, использующие `AuthContext`, не будут перерисовываться, и наоборот.

### Типичные Ошибки

*   **Забыли обернуть в `Provider`**: Компонент-потребитель получит дефолтное значение из `createContext()`, что часто приводит к ошибкам или неожидаемому поведению.
*   **Отсутствие мемоизации `value`**: Если `value` провайдера — это объект или массив, он будет создаваться заново при каждом рендере провайдера, вызывая ненужные перерисовки всех потребителей. Всегда используйте `useMemo` для объектов `value`.
*   **Использование Context API для *всего* глобального состояния**: Context API не предназначен для сложной логики управления состоянием, как Redux. Он лучше подходит для *передачи* данных.

### Практика: Комбинирование Контекстов

Давайте создадим общую обертку для нескольких провайдеров и посмотрим, как они взаимодействуют.

```jsx
// src/contexts/index.js (для объединения провайдеров)
import React from 'react';
import { ThemeProvider, ThemeContext } from './ThemeContext';
import { AuthProvider, AuthContext } from './AuthContext';

export const AppProviders = ({ children }) => (
  <ThemeProvider>
    <AuthProvider>
      {children}
    </AuthProvider>
  </ThemeProvider>
);

export { ThemeContext, AuthContext }; // Экспортируем сами контексты для удобства
```

```jsx
// src/App.js (обновленный)
import React from 'react';
import { AppProviders, ThemeContext, AuthContext } from './contexts';

function UserPanel() {
  const { user, login, logout } = React.useContext(AuthContext);
  const { theme } = React.useContext(ThemeContext); // Получаем тему для стилизации

  const panelStyle = {
    padding: '15px',
    margin: '20px 0',
    background: theme === 'dark' ? '#555' : '#f0f0f0',
    color: theme === 'dark' ? '#eee' : '#333',
    borderRadius: '8px',
  };

  return (
    <div style={panelStyle}>
      {user ? (
        <>
          <p>Привет, {user.name}!</p>
          <button onClick={logout}>Выйти</button>
        </>
      ) : (
        <>
          <p>Вы не авторизованы.</p>
          <button onClick={() => login({ name: 'Гость' })}>Войти как Гость</button>
        </>
      )}
    </div>
  );
}

function MainContent() {
  const { theme, toggleTheme } = React.useContext(ThemeContext);

  return (
    <div style={{ background: theme === 'dark' ? '#222' : '#fff', color: theme === 'dark' ? '#eee' : '#222', minHeight: '100vh', padding: '20px' }}>
      <h2>Основное Содержимое</h2>
      <p>Текущая тема: {theme}</p>
      <button onClick={toggleTheme}>Переключить тему</button>
      <UserPanel />
    </div>
  );
}

function App() {
  return (
    <AppProviders>
      <MainContent />
    </AppProviders>
  );
}

export default App;
```