# React Context API

Context API — это встроенный механизм React для передачи данных через дерево компонентов без необходимости передавать пропсы вручную на каждом уровне (prop drilling).

### Когда использовать Context API

Context идеально подходит для данных, которые можно считать "глобальными" для дерева компонентов:
- Текущий авторизованный пользователь.
- Тема оформления (светлая/темная).
- Выбранный язык (локализация).

### Механизм работы

```mermaid
graph TD
    Provider[Provider] --> C1[Component 1]
    Provider --> C2[Component 2]
    C1 --> C1a[Component 1a]
    C2 --> C2b[Consumer Component]
    style C2b fill:#f9f,stroke:#333,stroke-width:4px
```

### Пример использования

1. Создание контекста:
```tsx
const ThemeContext = React.createContext('light');
```

2. Обертывание провайдером:
```tsx
<ThemeContext.Provider value="dark">
  <Toolbar />
</ThemeContext.Provider>
```

3. Потребление значения:
```tsx
const theme = useContext(ThemeContext);
```

### Ограничения и проблемы

Context API не является полноценным стейт-менеджером. Основная проблема — **избыточные ререндеры**. Когда значение в `Provider` меняется, все компоненты, использующие `useContext(MyContext)`, перерисовываются, даже если они используют только ту часть объекта, которая не изменилась.

### Сравнение: Context vs State Managers

| Характеристика | Context API | Стейт-менеджеры (Zustand, MobX) |
| :--- | :--- | :--- |
| **Установка** | Встроено в React | Требуется библиотека |
| **Prop Drilling** | Решает | Решает |
| **Производительность** | Средняя (ререндеры) | Высокая (селекторы/атомы) |
| **Логика** | Только хранение | Middleware, логика, дебаггинг |
| **Сложность** | Низкая | От средней до высокой |

---

import { Playground } from '@/components/Playground';

## Интерактивный пример

Попробуйте изменить тему и посмотрите, как контекст передает значение глубоко вложенному компоненту.

<Playground
  template="vite-react"
  files={{
    'App.jsx': `import React, { createContext, useContext, useState } from 'react';

const ThemeContext = createContext('light');

const DeepChild = () => {
  const theme = useContext(ThemeContext);
  return (
    <div style={{
      padding: '10px',
      backgroundColor: theme === 'light' ? '#eee' : '#333',
      color: theme === 'light' ? '#000' : '#fff',
      borderRadius: '8px',
      marginTop: '10px'
    }}>
      Я — глубоко вложенный компонент. Моя тема: {theme}
    </div>
  );
};

const MiddleComponent = () => (
  <div style={{ border: '1px solid #ccc', padding: '10px' }}>
    <p>Я — промежуточный компонент (не получаю пропсы)</p>
    <DeepChild />
  </div>
);

export default function App() {
  const [theme, setTheme] = useState('light');

  return (
    <ThemeContext.Provider value={theme}>
      <div style={{ padding: '20px' }}>
        <button onClick={() => setTheme(t => t === 'light' ? 'dark' : 'light')}>
          Переключить тему
        </button>
        <MiddleComponent />
      </div>
    </ThemeContext.Provider>
  );
}`,
  }}
/>
