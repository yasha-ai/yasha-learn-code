## React: Тестирование React компонентов

Тестирование — это краеугольный камень разработки надежного и поддерживаемого ПО. В мире React это позволяет быть уверенным в том, что ваши компоненты ведут себя предсказуемо, а изменения не приводят к поломкам в других частях приложения.

### Концепция тестирования

**Что тестируем?** Мы проверяем, что UI-компоненты:
1.  Правильно отображаются с нужными данными (рендеринг).
2.  Корректно реагируют на действия пользователя (клики, ввод текста).
3.  Эффективно управляют состоянием и жизненным циклом.
4.  Интегрируются с другими компонентами и API.

**Основные инструменты:**
*   **Jest:** Популярный JavaScript фреймворк для тестирования, предоставляет запускатор тестов, ассерты (`expect`) и мощные возможности мокирования.
*   **React Testing Library (RTL):** Библиотека, разработанная специально для тестирования React-компонентов. Её философия — тестирование так, как пользователь взаимодействует с приложением, фокусируясь на DOM, а не на внутренней реализации компонентов. Это наш основной инструмент.

### Базовый пример: Тестирование кнопки

Начнем с простого компонента `Button` и напишем для него первый тест.

```jsx
// src/components/Button.jsx
import React from 'react';

function Button({ onClick, children }) {
  return (
    <button onClick={onClick}>
      {children}
    </button>
  );
}
export default Button;
```

```typescript
// src/components/Button.test.tsx
import { render, screen, fireEvent } from '@testing-library/react';
import Button from './Button';

describe('Button', () => {
  it('рендерит текст и вызывает onClick при клике', () => {
    // Создаем "мок-функцию" для отслеживания вызовов
    const handleClick = jest.fn();
    
    // Рендерим компонент в виртуальный DOM
    render(<Button onClick={handleClick}>Нажми меня</Button>);

    // Находим кнопку по ее тексту (как пользователь)
    const buttonElement = screen.getByText(/Нажми меня/i);
    
    // Проверяем, что кнопка отображается в документе
    expect(buttonElement).toBeInTheDocument();

    // Симулируем клик пользователя
    fireEvent.click(buttonElement);

    // Проверяем, что наша мок-функция была вызвана ровно один раз
    expect(handleClick).toHaveBeenCalledTimes(1);
  });
});
```

### Тестирование компонентов с Hooks (useState, useEffect)

Тестирование хуков не сильно отличается, поскольку RTL фокусируется на поведении.

```jsx
// src/components/Counter.jsx
import React, { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Счетчик: {count}</p>
      <button onClick={() => setCount(prev => prev + 1)}>Увеличить</button>
      <button onClick={() => setCount(prev => prev - 1)}>Уменьшить</button>
    </div>
  );
}
export default Counter;
```

```typescript
// src/components/Counter.test.tsx
import { render, screen, fireEvent } from '@testing-library/react';
import Counter from './Counter';

describe('Counter', () => {
  it('инкрементирует и декрементирует счетчик', () => {
    render(<Counter />);

    // Проверяем начальное состояние
    expect(screen.getByText(/Счетчик: 0/i)).toBeInTheDocument();

    // Кликаем по кнопке "Увеличить"
    fireEvent.click(screen.getByRole('button', { name: /Увеличить/i }));
    expect(screen.getByText(/Счетчик: 1/i)).toBeInTheDocument(); // Проверяем новое состояние

    // Кликаем по кнопке "Уменьшить"
    fireEvent.click(screen.getByRole('button', { name: /Уменьшить/i }));
    expect(screen.getByText(/Счетчик: 0/i)).toBeInTheDocument();
  });
});
```

Для тестирования **кастомных хуков** без привязки к компоненту, React 18+ предлагает хук `renderHook`.

```typescript
// src/hooks/useToggle.test.ts
import { renderHook, act } from '@testing-library/react';
import { useState, useCallback } from 'react';

// Пример простого кастомного хука
const useToggle = (initialValue = false) => {
  const [value, setValue] = useState(initialValue);
  const toggle = useCallback(() => setValue(v => !v), []);
  return [value, toggle] as const;
};

describe('useToggle', () => {
  it('должен переключать значение', () => {
    const { result } = renderHook(() => useToggle(false));

    expect(result.current[0]).toBe(false); // Начальное значение

    // Используем 'act' для симуляции обновлений состояния внутри хука
    act(() => {
      result.current[1](); // Вызываем функцию toggle
    });
    expect(result.current[0]).toBe(true);

    act(() => {
      result.current[1]();
    });
    expect(result.current[0]).toBe(false);
  });
});
```

### Оптимизация и лучшие практики

*   **Принцип Testing Library:** Тестируйте так, как пользователь! Избегайте доступа к внутреннему состоянию или деталям реализации.
*   **Приоритет селекторов:**
    *   `getByRole`: Наиболее надежный (например, `screen.getByRole('button', { name: /сохранить/i })`).
    *   `getByLabelText`
    *   `getByPlaceholderText`
    *   `getByText`
    *   `getByDisplayValue`
    *   `getByTestId`: Используйте как последнее средство, когда другие селекторы не подходят.
*   **Асинхронные тесты:** Для компонентов, которые загружают данные, используйте `async/await` и `waitFor` или `findBy*` селекторы (которые включают `waitFor`):
    ```typescript
    // Пример асинхронного теста
    it('отображает данные пользователя после загрузки', async () => {
      // Мокирование API запроса с Jest
      jest.spyOn(global, 'fetch').mockResolvedValueOnce({
        json: () => Promise.resolve({ name: 'Тестовый Пользователь' }),
      } as Response);

      render(<UserProfile userId={1} />);

      // Используем findByText, который ждет появления элемента
      expect(await screen.findByText(/Тестовый Пользователь/i)).toBeInTheDocument();
      expect(global.fetch).toHaveBeenCalledWith('/api/users/1');

      jest.restoreAllMocks(); // Очищаем мок
    });
    ```
*   **Мокирование зависимостей:** Изолируйте тесты от внешних систем (API, сторонние библиотеки) с помощью `jest.mock` или `jest.spyOn`.

### Типичные ошибки

*   **Тестирование деталей реализации:** Если ваш тест падает при незначительном рефакторинге компонента, скорее всего, вы тестируете детали реализации. Фокусируйтесь на **поведении**.
*   **Избыточное мокирование:** Мокируйте только то, что мешает тесту или является внешней зависимостью.
*   **Flaky tests (нестабильные тесты):** Тесты, которые иногда проходят, иногда падают. Часто это связано с неверной обработкой асинхронности. Используйте `await waitFor` и `findBy*`.
*   **Забывание очистки:** RTL автоматически очищает DOM после каждого теста, но если вы делаете что-то не стандартное, убедитесь, что все ресурсы освобождены.

### Практика

Создайте компонент `TodoList`, который позволяет добавлять и удалять задачи.
```jsx
// src/components/TodoList.jsx
import React, { useState } from 'react';

function TodoList() {
  const [todos, setTodos] = useState([]);
  const [inputValue, setInputValue] = useState('');

  const handleAddTodo = () => {
    if (inputValue.trim()) {
      setTodos([...todos, { id: Date.now(), text: inputValue }]);
      setInputValue('');
    }
  };

  const handleDeleteTodo = (id) => {
    setTodos(todos.filter(todo => todo.id !== id));
  };

  return (
    <div>
      <h2>Список задач</h2>
      <input
        type="text"
        value={inputValue}
        onChange={(e) => setInputValue(e.target.value)}
        placeholder="Новая задача"
      />
      <button onClick={handleAddTodo}>Добавить</button>
      <ul>
        {todos.map(todo => (
          <li key={todo.id}>
            {todo.text}
            <button onClick={() => handleDeleteTodo(todo.id)}>Удалить</button>
          </li>
        ))}
      </ul>
    </div>
  );
}
export default TodoList;
```

**Задача:** Напишите тесты для `TodoList` с использованием React Testing Library.
*   Убедитесь, что пустой список отображается корректно.
*   Добавьте новую задачу и проверьте ее появление в списке.
*   Удалите задачу и проверьте, что она исчезла.
### Практика

Попробуйте примеры в интерактивном редакторе:

<Playground template="react" />
