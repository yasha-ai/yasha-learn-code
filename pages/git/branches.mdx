```mdx
## Git: Ветки (Branches) - Изоляция и Параллельная Разработка

### Задача: Разработка в изоляции

Ветки в Git — это мощный инструмент, который позволяет вам отходить от основной линии разработки и работать над новыми функциями, исправлениями ошибок или экспериментами, не затрагивая при этом стабильный код. Это как если бы у вас была копия всего проекта, на которой вы можете свободно вносить изменения, а затем, когда работа завершена, "слить" её обратно в основной проект.

Каждая ветка — это по сути лишь подвижный указатель на один из коммитов. Когда вы создаете новый коммит, ветка, на которой вы находитесь, перемещается вперед, указывая на новый коммит.

```
       C1 -- C2 -- C3 (main)
        \
         D1 -- D2 (feature-x)
```
Здесь `main` и `feature-x` — это ветки, указывающие на разные коммиты.

### Команды для работы с ветками

*   **Просмотр веток:**
    ```bash
    git branch
    ```
    _Покажет список всех локальных веток. Звездочка `*` указывает на текущую ветку._

*   **Создание новой ветки:**
    ```bash
    git branch <имя_новой_ветки>
    ```
    _Создаст новую ветку, указывающую на тот же коммит, что и текущая ветка._

*   **Переключение между ветками:**
    *   **Современный способ (рекомендуется):**
        ```bash
        git switch <имя_ветки>
        ```
        _Переключит вас на указанную ветку. Все файлы в рабочей директории будут приведены в состояние последнего коммита этой ветки._
    *   **Устаревший способ (также работает):**
        ```bash
        git checkout <имя_ветки>
        ```
        _Аналогично `git switch`._

*   **Создание и переключение на новую ветку (комбинированные команды):**
    *   **Современный способ (рекомендуется):**
        ```bash
        git switch -c <имя_новой_ветки>
        ```
        _Создаст новую ветку и сразу же переключит на нее._
    *   **Устаревший способ (также работает):**
        ```bash
        git checkout -b <имя_новой_ветки>
        ```
        _Аналогично `git switch -c`._

*   **Слияние веток:**
    ```bash
    git merge <ветка_для_слияния>
    ```
    _Вливает изменения из указанной ветки в текущую ветку. **Важно:** перед слиянием переключитесь на ту ветку, в которую хотите влить изменения (обычно `main` или `develop`)._

*   **Удаление ветки:**
    ```bash
    git branch -d <имя_ветки>
    ```
    _Удалит указанную ветку. Git предотвратит удаление ветки, если в ней есть незамерженные коммиты, чтобы избежать потери данных._
    ```bash
    git branch -D <имя_ветки>
    ```
    _Принудительное удаление ветки, даже если в ней есть незамерженные коммиты. Используйте осторожно!_

### Примеры использования

Представим, что у вас есть репозиторий с одним коммитом: `C1 (main)`.

1.  **Создаем ветку для новой функции:**
    ```bash
    git switch -c feature/add-login
    ```
    _Теперь вы находитесь на ветке `feature/add-login`._
    ```
           C1 (main, feature/add-login)
    ```

2.  **Вносим изменения и коммитим в новой ветке:**
    _Добавляем файлы, пишем код..._
    ```bash
    git add .
    git commit -m "Добавлена базовая форма входа"
    ```
    _Теперь ветка `feature/add-login` указывает на `C2`, а `main` все еще на `C1`._
    ```
           C1 (main)
            \
             C2 (feature/add-login)
    ```

3.  **Переключаемся на `main` и вливаем изменения:**
    ```bash
    git switch main
    ```
    _Вы вернулись на ветку `main`._
    ```bash
    git merge feature/add-login
    ```
    _Git выполнит "Fast-forward" слияние, так как `main` является прямым предком `feature/add-login`. `main` теперь указывает на `C2`._
    ```
           C1 -- C2 (main, feature/add-login)
    ```

4.  **Удаляем ветку после слияния (Git Best Practice):**
    ```bash
    git branch -d feature/add-login
    ```
    _Ветка `feature/add-login` удалена. `main` остается на `C2`._
    ```
           C1 -- C2 (main)
    ```

### Типичные проблемы и решения

*   **Коммит в неправильную ветку:** Вы начали работать, забыв переключиться на новую ветку.
    *   _Решение:_ Если коммит еще не пушен, можно сбросить его (`git reset HEAD^`), создать новую ветку (`git switch -c new-feature`), а затем применить изменения (`git cherry-pick <ID_коммита>` или просто заново закоммитить).

*   **Конфликты слияния:** При попытке слияния Git сообщает о конфликтах, когда изменения в одном и том же месте файла были сделаны в обеих ветках.
    *   _Решение:_ Git помечает конфликтные места. Вам нужно вручную отредактировать файлы, выбрать нужные изменения, затем `git add <файл>` и `git commit`.

*   **Удаление неслитой ветки:** Попытка `git branch -d` выдает ошибку.
    *   _Решение:_ Либо сначала слейте ветку в другую (`git merge`), либо, если вы уверены, что ветка больше не нужна и ее изменения можно потерять, используйте `git branch -D`.

### Практика

1.  Создайте новый репозиторий:
    ```bash
    mkdir my-project && cd my-project
    git init
    touch README.md
    git add . && git commit -m "Initial commit"
    ```
2.  Создайте ветку `feature/dark-mode` и переключитесь на неё:
    ```bash
    git switch -c feature/dark-mode
    ```
3.  Создайте файл `style.css` с содержимым `body { background-color: #333; color: #fff; }`, добавьте и закоммитьте его:
    ```bash
    echo "body { background-color: #333; color: #fff; }" > style.css
    git add style.css
    git commit -m "Добавлен темный режим"
    ```
4.  Переключитесь обратно на `main`:
    ```bash
    git switch main
    ```
5.  Создайте ветку `bugfix/typo` и переключитесь на неё:
    ```bash
    git switch -c bugfix/typo
    ```
6.  Отредактируйте `README.md`, изменив "Initial commit" на "Initial setup", закоммитьте:
    ```bash
    echo "Initial setup" > README.md
    git add README.md
    git commit -m "Исправлена опечатка в README"
    ```
7.  Переключитесь на `main` и слейте `bugfix/typo`:
    ```bash
    git switch main
    git merge bugfix/typo
    ```
8.  Удалите ветку `bugfix/typo`:
    ```bash
    git branch -d bugfix/typo
    ```
9.  Слейте `feature/dark-mode` в `main`:
    ```bash
    git merge feature/dark-mode
    ```
10. Удалите ветку `feature/dark-mode`:
    ```bash
    git branch -d feature/dark-mode
    ```
```