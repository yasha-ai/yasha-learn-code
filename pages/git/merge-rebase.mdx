## Git: Merge vs Rebase – Интеграция изменений чисто и эффективно

**Задача**: В этом уроке мы разберем два основных способа интеграции изменений из одной ветки в другую: `git merge` и `git rebase`. Вы узнаете, когда использовать каждый из них, их преимущества, недостатки и как избежать типичных проблем. Понимание этих инструментов критически важно для работы в команде и поддержания чистого репозитория.

### Git Merge: Сохраняем историю как она есть

**Концепция**: `git merge` объединяет две истории, создавая новый "merge commit". Этот коммит имеет двух родителей, указывая на последний коммит обеих объединяемых веток. Это неинвазивная операция: она не изменяет существующие коммиты, а лишь добавляет новый.

**Визуальная схема (3-way merge):**
```
      A -- B -- C (main)
           \      /
            D -- E (feature)
```
После `git merge feature` в `main`:
```
      A -- B -- C -- M (main)
           \      /
            D ---- E
```
*(Где `M` – это merge commit, объединяющий `C` и `E`)*

**Команды**:
Сначала переключитесь на ветку, в которую хотите интегрировать изменения (целевую ветку):
```bash
git switch main
git merge feature # Объединить ветку 'feature' в текущую 'main'
```

**Последствия**:
*   Создается новый коммит (`M`).
*   История сохраняется точно так, как она развивалась, но может выглядеть ветвистой.
*   Отлично подходит для интеграции в общедоступные, стабильные ветки.

**Пример 1: Fast-forward merge (если целевая ветка не изменилась)**
```bash
git switch main
git checkout -b feature-ff
echo "Initial feature content" > feature.txt
git add feature.txt
git commit -m "feat: Add initial feature content"

git switch main # main не изменилась с момента создания feature-ff
git merge feature-ff # Произойдет fast-forward: указатель main просто переместится вперед
```
_**Результат:** Коммиты `feature-ff` теперь напрямую на `main` без merge-коммита._

**Пример 2: Merge с конфликтом**
```bash
git switch main
git checkout -b conflict-branch
echo "Line 1 from conflict-branch" > conflict.txt
git add conflict.txt
git commit -m "feat: Add line from conflict-branch"

git switch main
echo "Line 1 from main" > conflict.txt # Изменяем ту же строку
git add conflict.txt
git commit -m "feat: Add line from main"

git merge conflict-branch # Вызовет конфликт, так как одна и та же строка изменена
# !!! Откройте conflict.txt, разрешите конфликт вручную !!!
# Затем:
git add conflict.txt
git commit -m "Merge branch 'conflict-branch' into main" # Создается merge commit
```
_**Результат:** История с merge-коммитом, разрешившим конфликт._

### Git Rebase: Переписываем историю для чистоты

**Концепция**: `git rebase` берет коммиты из вашей ветки и "перемещает" их поверх другой ветки. Это **переписывает историю**, создавая новые коммиты для каждого перенесенного, вместо старых. Цель – получить чистую, линейную историю.

**Визуальная схема**:
```
      A -- B -- C (main)
           \
            D -- E (feature)
```
После `git rebase main` в `feature`:
```
      A -- B -- C -- D' -- E' (feature)
```
*(Где `D'`, `E'` – это новые коммиты, идентичные `D`, `E`, но с новым родителем `C`)*

**Команды**:
Переключитесь на ветку, которую вы хотите перебазировать (обычно ваша фиче-ветка):
```bash
git switch feature
git rebase main # Перенести коммиты feature поверх актуальной main
# (Если есть конфликты, разрешите их, затем 'git rebase --continue')
```
После успешного ребейза, чтобы `main` отразила эти изменения:
```bash
git switch main
git merge feature # Обычно это будет fast-forward, так как feature теперь потомок main
```

**Последствия**:
*   Создается новая линейная история, что облегчает ее чтение.
*   **Осторожно**: переписывает историю (изменяет SHA1-хеши коммитов), что опасно для общих веток.

**Пример Rebase**:
```bash
git switch main
git checkout -b feature-rebase
echo "Rebase feature A" > rebase.txt
git add rebase.txt
git commit -m "feat: rebase feature A"
echo "Rebase feature B" >> rebase.txt
git add rebase.txt
git commit -m "feat: rebase feature B"

git switch main
echo "Main update for rebase" > main.txt
git add main.txt
git commit -m "feat: main updated"

git switch feature-rebase
git rebase main # Переместит коммиты "rebase feature A" и "rebase feature B" поверх "main updated"
# (Если возникнут конфликты, разрешите их и выполните 'git rebase --continue')

git switch main
git merge feature-rebase # Fast-forward merge: main теперь указывает на последний коммит feature-rebase
```
_**Результат:** Чистая, линейная история в `main` без merge-коммитов._

### Когда что использовать (Лучшие практики Git)

*   **Используйте `git merge` когда:**
    *   Интегрируете в **общие, опубликованные ветки** (`main`, `develop`). Merge-коммиты показывают, когда были интегрированы фичи, сохраняя исторический контекст.
    *   Вы хотите сохранить **точную, неизменную историю** с merge-коммитами, даже если она выглядит менее линейной.
    *   Вы работаете в команде и не хотите заставлять коллег делать `git pull --rebase` или `git push --force`.
*   **Используйте `git rebase` когда:**
    *   Вы хотите поддерживать **чистую, линейную историю** в своей **локальной, неопубликованной ветке** перед слиянием с `main`.
    *   Вам нужно "подтянуть" изменения из `main` в вашу фиче-ветку, чтобы избежать большого merge-коммита или конфликтов при финальном слиянии. Регулярный ребейз помогает раньше найти конфликты.
    *   **Золотое правило**: **НИКОГДА** не делайте `git rebase` на ветке, которую вы уже опубликовали (т.е., `git push` ее), и с которой работают другие люди! Это изменит историю, которую они уже получили, и приведет к серьезным проблемам с синхронизацией.

### Типичные проблемы и их решения

*   **Конфликты**: Могут возникнуть при обоих операциях. При rebase конфликт может появиться для каждого переносимого коммита, что может быть утомительно.
    *   **Решение**: Разрешите конфликтные файлы вручную, `git add .`, затем `git commit` (для merge) или `git rebase --continue` (для rebase). Для отмены rebase: `git rebase --abort`.
*   **Переписывание общей истории (`rebase`)**: Главная опасность rebase. Если вы перебазируете опубликованную ветку, другим участникам команды будет сложно синхронизироваться.
    *   **Решение**: Следуйте золотому правилу. Если вы *действительно* должны (например, после squashing приватных коммитов) и ветка только ваша, используйте `git push --force-with-lease` для безопасного принудительного push.

### Практика

1.  Создайте новый репозиторий и инициализируйте Git.
    ```bash
    mkdir git-rebase-merge-practice
    cd git-rebase-merge-practice
    git init
    ```
2.  Создайте начальный коммит на `main`.
    ```bash
    echo "Initial content" > file.txt
    git add .
    git commit -m "Initial commit"
    ```
3.  **Практика `git merge`**:
    *   Создайте ветку `my-feature-merge` и сделайте 2 коммита.
        ```bash
        git switch -c my-feature-merge
        echo "Feature A" > feature.txt && git add . && git commit -m "feat: A"
        echo "Feature B" >> feature.txt && git add . && git commit -m "feat: B"
        ```
    *   Переключитесь на `main` и сделайте 1 коммит (чтобы вызвать merge commit).
        ```bash
        git switch main
        echo "Main update 1" >> file.txt && git add . && git commit -m "refactor: Main update 1"
        ```
    *   Объедините `my-feature-merge` в `main`. Проанализируйте `git log --graph --oneline`.
        ```bash
        git merge my-feature-merge
        git log --graph --oneline
        ```
4.  **Практика `git rebase`**:
    *   Создайте ветку `my-feature-rebase` из актуального `main`.
        ```bash
        git switch -c my-feature-rebase
        echo "Rebase Feature X" > rebase-feature.txt && git add . && git commit -m "feat: X"
        echo "Rebase Feature Y" >> rebase-feature.txt && git add . && git commit -m "feat: Y"
        ```
    *   Переключитесь на `main` и сделайте 1 коммит (чтобы `main` "ушел" вперед).
        ```bash
        git switch main
        echo "Main update 2" >> file.txt && git add . && git commit -m "refactor: Main update 2"
        ```
    *   Переключитесь на `my-feature-rebase` и сделайте `git rebase main`. Разрешите конфликты, если есть.
        ```bash
        git switch my-feature-rebase
        git rebase main
        # (Если конфликт: разрешите, git add ., git rebase --continue)
        ```
    *   Переключитесь на `main` и сделайте `git merge my-feature-rebase`. Проанализируйте `git log --graph --oneline`.
        ```bash
        git switch main
        git merge my-feature-rebase # Это должен быть fast-forward merge
        git log --graph --oneline
        ```
    Сравните истории после `merge` и `rebase`. Обратите внимание на наличие merge-коммита и линейность истории.