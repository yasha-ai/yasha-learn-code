import { Sandpack } from '@codesandbox/sandpack-react'

# Singleton (Одиночка)

Singleton — паттерн проектирования, гарантирующий что класс имеет только **один экземпляр** и предоставляющий глобальную точку доступа к нему. В JavaScript реализуется несколькими способами — от простого объекта до классов с приватным конструктором.

## Простейший Singleton — объект

Если объект создаётся один раз — он уже Singleton:

```javascript
// Простейший синглтон — объект-литерал
const config = {
  host: 'localhost',
  port: 3000,
  debug: false,
  
  get(key) { return this[key] },
  set(key, value) { this[key] = value },
}

config.set('debug', true)
console.log(config.get('debug')) // true

// Это один и тот же объект везде в коде
import { config } from './config.js'
```

## Singleton через Class

```javascript
class Database {
  static #instance = null // приватное статическое поле
  #connection = null
  
  constructor(connectionString) {
    if (Database.#instance) {
      return Database.#instance // возвращаем существующий экземпляр
    }
    
    // Первый вызов — инициализируем
    this.#connection = { url: connectionString, connected: false }
    Database.#instance = this
  }
  
  connect() {
    this.#connection.connected = true
    console.log(`Подключено к ${this.#connection.url}`)
    return this
  }
  
  query(sql) {
    if (!this.#connection.connected) throw new Error('Нет соединения')
    console.log(`Запрос: ${sql}`)
    return []
  }
  
  static getInstance() {
    if (!Database.#instance) {
      new Database('postgresql://localhost/mydb')
    }
    return Database.#instance
  }
}

const db1 = new Database('postgresql://host1/db')
const db2 = new Database('postgresql://host2/db') // возвращает тот же экземпляр!

console.log(db1 === db2) // true

// Рекомендуется через getInstance
const db = Database.getInstance()
db.connect().query('SELECT * FROM users')
```

## Singleton через IIFE и замыкание

```javascript
const AppState = (function() {
  let instance

  function createInstance() {
    const state = {
      user: null,
      theme: 'dark',
      language: 'ru',
      notifications: [],
    }

    return {
      get(key) { return state[key] },
      set(key, value) { state[key] = value; return this },
      addNotification(msg) { 
        state.notifications.push({ msg, time: Date.now() })
        return this
      },
      getNotifications() { return [...state.notifications] },
    }
  }

  return {
    getInstance() {
      if (!instance) instance = createInstance()
      return instance
    }
  }
})()

const state1 = AppState.getInstance()
const state2 = AppState.getInstance()

state1.set('user', { name: 'Алексей' }).addNotification('Добро пожаловать!')
console.log(state2.get('user').name) // 'Алексей' — тот же объект!
console.log(state1 === state2) // true
```

## Lazy Singleton

Создаётся только при первом обращении:

```javascript
class ServiceLocator {
  static #services = new Map()

  static register(name, factory) {
    this.#services.set(name, { factory, instance: null })
  }

  static get(name) {
    const service = this.#services.get(name)
    if (!service) throw new Error(`Сервис "${name}" не зарегистрирован`)
    
    // Lazy: создаём экземпляр только при первом запросе
    if (!service.instance) {
      service.instance = service.factory()
    }
    return service.instance
  }
}

// Регистрируем сервисы
ServiceLocator.register('logger', () => ({
  log: (msg) => console.log(`[LOG] ${msg}`)
}))

ServiceLocator.register('cache', () => {
  const store = new Map()
  return {
    set: (k, v) => store.set(k, v),
    get: (k) => store.get(k),
  }
})

// Используем
const logger = ServiceLocator.get('logger')
logger.log('Привет!')

const cache1 = ServiceLocator.get('cache')
const cache2 = ServiceLocator.get('cache')
cache1.set('key', 'value')
console.log(cache2.get('key')) // 'value' — тот же экземпляр
console.log(cache1 === cache2) // true
```

## Module Singleton (ES Modules)

В ES Modules каждый файл — уже Singleton по умолчанию:

```javascript
// store.js — выполняется только один раз при первом импорте
let _state = {
  count: 0,
  user: null,
}

export function getState() { return { ..._state } }
export function setState(updates) { Object.assign(_state, updates) }
export function increment() { _state.count++ }

// Любой файл, который импортирует store.js, получает тот же экземпляр
// import { getState, setState } from './store.js'
```

## Когда использовать Singleton

**✅ Подходит:**
- Конфигурация приложения
- Пул соединений с БД
- Logger/система логирования
- Кэш
- EventBus / глобальный шина событий

**❌ Избегать:**
- Если состояние должно быть независимым (тесты!)
- Как замена правильной архитектуре
- Когда создаёт скрытые зависимости

> **Тестирование:** Синглтоны усложняют тестирование. Используйте Dependency Injection или позвольте сбрасывать экземпляр между тестами.

## Интерактивный пример

<Sandpack
  template="vanilla"
  files={{
    "/index.html": `<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>Singleton</title>
  <link rel="stylesheet" href="/styles.css">
</head>
<body>
  <h2>Singleton — Глобальный магазин</h2>
  <div class="controls">
    <input id="key" placeholder="ключ" value="username">
    <input id="value" placeholder="значение" value="Алексей">
    <button id="set">Сохранить</button>
    <button id="get">Получить</button>
  </div>
  <div id="output"></div>
  <h3>Проверка: оба экземпляра одинаковы?</h3>
  <button id="check">Проверить ===</button>
  <div id="check-result"></div>
  <script src="/index.js"></script>
</body>
</html>`,
    "/styles.css": `body { font-family: sans-serif; background: #1e1e2e; color: #cdd6f4; padding: 20px; }
h2,h3 { color: #89b4fa; }
.controls { display: flex; gap: 8px; flex-wrap: wrap; margin: 12px 0; }
input { background: #313244; border: 1px solid #45475a; color: #cdd6f4; padding: 8px 12px; border-radius: 6px; }
button { background: #89b4fa; color: #1e1e2e; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-weight: bold; }
.result { background: #313244; border-radius: 6px; padding: 10px 14px; margin: 6px 0; font-family: monospace; }
.true { color: #a6e3a1; } .false { color: #f38ba8; }`,
    "/index.js": `// Singleton через Class
class Store {
  static #instance = null
  #data = {}

  constructor() {
    if (Store.#instance) return Store.#instance
    Store.#instance = this
  }

  set(key, value) { this.#data[key] = value }
  get(key) { return this.#data[key] }
  getAll() { return { ...this.#data } }
}

// Создаём два "разных" экземпляра
const store1 = new Store()
const store2 = new Store()

function log(msg, type = '') {
  const d = document.createElement('div')
  d.className = 'result ' + type
  d.textContent = msg
  document.getElementById('output').prepend(d)
}

document.getElementById('set').addEventListener('click', () => {
  const k = document.getElementById('key').value
  const v = document.getElementById('value').value
  store1.set(k, v)
  log(\`store1.set("\${k}", "\${v}") ✅\`)
})

document.getElementById('get').addEventListener('click', () => {
  const k = document.getElementById('key').value
  log(\`store2.get("\${k}") = "\${store2.get(k)}" (из store2!)\`)
})

document.getElementById('check').addEventListener('click', () => {
  const same = store1 === store2
  document.getElementById('check-result').innerHTML =
    \`<div class="result \${same}">store1 === store2: \${same} \${same ? '✅ Один объект!' : '❌ Разные'}</div>\`
})
`
  }}
  options={{ showNavigator: false, showLineNumbers: true, editorHeight: 380 }}
/>
