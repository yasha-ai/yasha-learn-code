## JavaScript: Модули (ES6)

Модули в JavaScript — это способ организации кода в отдельные, переиспользуемые файлы. До появления ES6 модулей (CommonJS и AMD были до этого), для разделения кода приходилось использовать сложные паттерны или полагаться на глобальную область видимости, что приводило к конфликтам имен и затрудняло поддержку. ES6 модули решили эти проблемы, предоставив стандартизированный синтаксис для экспорта и импорта функциональности.

**Основные преимущества:**
*   **Изоляция:** Каждый модуль имеет свою собственную область видимости. Переменные и функции внутри модуля не влияют на глобальную область видимости и не конфликтуют с другими модулями, пока они не экспортированы.
*   **Переиспользование:** Легко использовать один и тот же код в разных частях приложения.
*   **Управляемые зависимости:** Четко видно, от чего зависит каждый модуль.
*   **Производительность (Tree-shaking):** Современные бандлеры могут удалять неиспользуемый код из модулей, уменьшая размер бандла.

### Экспорт (`export`)

Используется для предоставления функциональности из модуля.

#### 1. Именованный экспорт (Named Exports)
Можно экспортировать несколько сущностей из файла.

```javascript
// utils.js
export const PI = 3.14159;

export function sum(a, b) {
  return a + b;
}

export class Calculator {
  add(a, b) {
    return a + b;
  }
}
```

Или экспортировать их в конце файла:

```javascript
// another-utils.js
const GREETING = "Hello from module!";

function subtract(a, b) {
  return a - b;
}

export { GREETING, subtract };
```

#### 2. Экспорт по умолчанию (Default Export)
Модуль может иметь только один экспорт по умолчанию. Обычно используется для основной сущности, которую предоставляет модуль.

```javascript
// myModule.js
class MyDefaultClass {
  constructor(name) {
    this.name = name;
  }
  sayHello() {
    console.log(`Hello, I'm ${this.name}`);
  }
}

export default MyDefaultClass;
```

Можно комбинировать именованные и дефолтный экспорты:

```javascript
// combined.js
export const config = {
  version: '1.0.0'
};

const DEFAULT_MESSAGE = "Это сообщение по умолчанию.";
export default DEFAULT_MESSAGE;
```

### Импорт (`import`)

Используется для получения функциональности из других модулей.

#### 1. Именованный импорт
Используем фигурные скобки `{}` и точное имя экспортируемой сущности.

```javascript
// app.js
import { PI, sum } from './utils.js';
import { GREETING, subtract } from './another-utils.js';

console.log(PI); // 3.14159
console.log(sum(5, 3)); // 8
console.log(GREETING); // Hello from module!
console.log(subtract(10, 4)); // 6
```

Можно переименовать импортируемые сущности:

```javascript
import { PI as mathPI, sum as addNumbers } from './utils.js';

console.log(mathPI); // 3.14159
console.log(addNumbers(1, 2)); // 3
```

#### 2. Импорт по умолчанию
Для импорта по умолчанию не нужны фигурные скобки, и вы можете дать ему любое имя.

```javascript
// app.js
import MyClass from './myModule.js'; // `MyClass` - произвольное имя

const instance = new MyClass('Alice');
instance.sayHello(); // Hello, I'm Alice
```

#### 3. Импорт всего как объекта (Namespace Import)
Импортирует все именованные экспорты как свойства одного объекта.

```javascript
// app.js
import * as Utils from './utils.js';

console.log(Utils.PI); // 3.14159
console.log(Utils.sum(2, 2)); // 4

const calc = new Utils.Calculator();
console.log(calc.add(7, 3)); // 10
```

#### 4. Комбинированный импорт
Импорт по умолчанию вместе с именованными импортами:

```javascript
// app.js
import DefaultMessage, { config } from './combined.js';

console.log(DefaultMessage); // Это сообщение по умолчанию.
console.log(config.version); // 1.0.0
```

### Переэкспорт (Re-export)

Позволяет экспортировать сущности из другого модуля, не импортируя их явно в текущий. Удобно для создания "сборщиков" модулей (barrel files).

```javascript
// components/index.js (файл-сборщик)
export { sum, PI } from './utils.js';
export { default as MyClass } from './myModule.js'; // Переэкспортируем дефолт как именованный
// Или все именованные экспорты из файла:
// export * from './another-utils.js';
```

Теперь из `app.js` можно импортировать так:

```javascript
// app.js
import { sum, PI, MyClass } from './components/index.js';

console.log(sum(PI, 1));
const myInstance = new MyClass('Bob');
myInstance.sayHello();
```

### Динамические импорты (`import()`)

Позволяют загружать модули асинхронно, во время выполнения, а не на старте приложения. Возвращают промис, который разрешается в объект модуля.

```javascript
// app.js
const loadAndUseModule = async () => {
  // Например, загружаем модуль только при клике на кнопку или в зависимости от роута
  if (true /* какое-то условие */) {
    const { sum, PI } = await import('./utils.js');
    console.log(`Динамический импорт: ${sum(PI, 1)}`);
  }
};

loadAndUseModule(); // Вызовем для примера
```
Полезно для "ленивой" загрузки частей приложения (code splitting) и улучшения производительности.

### Практика и советы

*   **Расширение файлов:** В браузерах и Node.js (когда тип модуля `module` в `package.json` или `.mjs` расширение) требуется указывать полное расширение файла `.js` (или `.mjs`) при импорте.
*   **Относительные/абсолютные пути:** Используйте относительные пути (начинаются с `./` или `../`) для ваших модулей. Для библиотек из `node_modules` можно использовать голые имена (например, `import React from 'react';`).
*   **Transpilation/Bundling:** Хотя ES6 модули являются стандартом, для широкой поддержки в старых браузерах и для оптимизации (tree-shaking, code splitting) часто используются инструменты вроде Webpack, Rollup или Parcel.
*   **Top-Level `await`:** В ES модулях можно использовать `await` на верхнем уровне файла без оборачивания его в асинхронную функцию. Это удобно, например, для инициализации модуля, зависящей от асинхронных операций.

```javascript
// configLoader.js
// Предположим, что someAsyncConfig() возвращает промис с конфигурацией
export const config = await someAsyncConfig();
```

---

**Задание:**
Создайте два файла: `mathOperations.js` и `main.js`.
1.  В `mathOperations.js`:
    *   Экспортируйте именованную функцию `multiply(a, b)`.
    *   Экспортируйте именованную константу `E = 2.71828`.
    *   Экспортируйте по умолчанию класс `Calculator`, который имеет метод `divide(a, b)`.
2.  В `main.js`:
    *   Импортируйте все из `mathOperations.js` как `MathUtils` (namespace import).
    *   Импортируйте `Calculator` по умолчанию как `MyCalculator`.
    *   Используйте `multiply`, `E` и `divide` для вывода результатов в консоль.
### Практика

Попробуйте примеры в интерактивном редакторе:

<Sandpack template="vanilla">

```js index.js
// Демонстрация ES6 модулей
import { PI, sum, Calculator } from './utils.js';
import { GREETING, subtract } from './helpers.js';
import MyClass from './myModule.js';
import * as AllUtils from './utils.js';

document.body.style.fontFamily = 'Arial, sans-serif';
document.body.style.padding = '20px';

const title = document.createElement('h2');
title.textContent = 'ES6 Модули - Демонстрация';
document.body.appendChild(title);

// 1. Именованный импорт
const section1 = document.createElement('div');
section1.innerHTML = `
  <h3>1. Именованный импорт (Named Import)</h3>
  <p>import { PI, sum } from './utils.js'</p>
  <p><strong>PI:</strong> ${PI}</p>
  <p><strong>sum(5, 3):</strong> ${sum(5, 3)}</p>
`;
document.body.appendChild(section1);

// 2. Импорт класса
const calc = new Calculator();
const section2 = document.createElement('div');
section2.innerHTML = `
  <h3>2. Импорт класса</h3>
  <p><strong>Calculator.multiply(4, 5):</strong> ${calc.multiply(4, 5)}</p>
  <p><strong>Calculator.divide(20, 4):</strong> ${calc.divide(20, 4)}</p>
`;
section2.style.marginTop = '20px';
document.body.appendChild(section2);

// 3. Импорт из другого модуля
const section3 = document.createElement('div');
section3.innerHTML = `
  <h3>3. Множественные модули</h3>
  <p>import { GREETING, subtract } from './helpers.js'</p>
  <p><strong>GREETING:</strong> ${GREETING}</p>
  <p><strong>subtract(10, 4):</strong> ${subtract(10, 4)}</p>
`;
section3.style.marginTop = '20px';
document.body.appendChild(section3);

// 4. Default импорт
const instance = new MyClass('Яша');
const message = instance.sayHello();
const section4 = document.createElement('div');
section4.innerHTML = `
  <h3>4. Default Import</h3>
  <p>import MyClass from './myModule.js'</p>
  <p><strong>Результат:</strong> ${message}</p>
`;
section4.style.marginTop = '20px';
document.body.appendChild(section4);

// 5. Namespace импорт
const section5 = document.createElement('div');
section5.innerHTML = `
  <h3>5. Namespace Import</h3>
  <p>import * as AllUtils from './utils.js'</p>
  <p><strong>AllUtils.PI:</strong> ${AllUtils.PI}</p>
  <p><strong>AllUtils.sum(1, 2):</strong> ${AllUtils.sum(1, 2)}</p>
`;
section5.style.marginTop = '20px';
document.body.appendChild(section5);

// Итоги
const summary = document.createElement('div');
summary.innerHTML = `
  <h3>Итоги:</h3>
  <ul>
    <li>✅ Именованный экспорт/импорт - для множественных сущностей</li>
    <li>✅ Default экспорт - для основной сущности модуля</li>
    <li>✅ Namespace импорт - для импорта всего как объекта</li>
    <li>✅ Каждый модуль имеет свою область видимости</li>
  </ul>
`;
summary.style.backgroundColor = '#e8f5e9';
summary.style.padding = '15px';
summary.style.borderRadius = '8px';
summary.style.marginTop = '20px';
document.body.appendChild(summary);

console.log('Модули успешно импортированы!');
```

```js utils.js
// Именованные экспорты
export const PI = 3.14159;

export function sum(a, b) {
  return a + b;
}

export class Calculator {
  multiply(a, b) {
    return a * b;
  }
  
  divide(a, b) {
    if (b === 0) throw new Error('Division by zero');
    return a / b;
  }
}
```

```js helpers.js
// Другой модуль с именованными экспортами
export const GREETING = "Привет из модуля helpers!";

export function subtract(a, b) {
  return a - b;
}

export const VERSION = '1.0.0';
```

```js myModule.js
// Default экспорт
class MyDefaultClass {
  constructor(name) {
    this.name = name;
  }
  
  sayHello() {
    return `Привет, меня зовут ${this.name}!`;
  }
}

export default MyDefaultClass;
```

</Sandpack>
