## JavaScript: Модули (ES6)

Модули в JavaScript — это способ организации кода в отдельные, переиспользуемые файлы. До появления ES6 модулей (CommonJS и AMD были до этого), для разделения кода приходилось использовать сложные паттерны или полагаться на глобальную область видимости, что приводило к конфликтам имен и затрудняло поддержку. ES6 модули решили эти проблемы, предоставив стандартизированный синтаксис для экспорта и импорта функциональности.

**Основные преимущества:**
*   **Изоляция:** Каждый модуль имеет свою собственную область видимости. Переменные и функции внутри модуля не влияют на глобальную область видимости и не конфликтуют с другими модулями, пока они не экспортированы.
*   **Переиспользование:** Легко использовать один и тот же код в разных частях приложения.
*   **Управляемые зависимости:** Четко видно, от чего зависит каждый модуль.
*   **Производительность (Tree-shaking):** Современные бандлеры могут удалять неиспользуемый код из модулей, уменьшая размер бандла.

### Экспорт (`export`)

Используется для предоставления функциональности из модуля.

#### 1. Именованный экспорт (Named Exports)
Можно экспортировать несколько сущностей из файла.

```javascript
// utils.js
export const PI = 3.14159;

export function sum(a, b) {
  return a + b;
}

export class Calculator {
  add(a, b) {
    return a + b;
  }
}
```

Или экспортировать их в конце файла:

```javascript
// another-utils.js
const GREETING = "Hello from module!";

function subtract(a, b) {
  return a - b;
}

export { GREETING, subtract };
```

#### 2. Экспорт по умолчанию (Default Export)
Модуль может иметь только один экспорт по умолчанию. Обычно используется для основной сущности, которую предоставляет модуль.

```javascript
// myModule.js
class MyDefaultClass {
  constructor(name) {
    this.name = name;
  }
  sayHello() {
    console.log(`Hello, I'm ${this.name}`);
  }
}

export default MyDefaultClass;
```

Можно комбинировать именованные и дефолтный экспорты:

```javascript
// combined.js
export const config = {
  version: '1.0.0'
};

const DEFAULT_MESSAGE = "Это сообщение по умолчанию.";
export default DEFAULT_MESSAGE;
```

### Импорт (`import`)

Используется для получения функциональности из других модулей.

#### 1. Именованный импорт
Используем фигурные скобки `{}` и точное имя экспортируемой сущности.

```javascript
// app.js
import { PI, sum } from './utils.js';
import { GREETING, subtract } from './another-utils.js';

console.log(PI); // 3.14159
console.log(sum(5, 3)); // 8
console.log(GREETING); // Hello from module!
console.log(subtract(10, 4)); // 6
```

Можно переименовать импортируемые сущности:

```javascript
import { PI as mathPI, sum as addNumbers } from './utils.js';

console.log(mathPI); // 3.14159
console.log(addNumbers(1, 2)); // 3
```

#### 2. Импорт по умолчанию
Для импорта по умолчанию не нужны фигурные скобки, и вы можете дать ему любое имя.

```javascript
// app.js
import MyClass from './myModule.js'; // `MyClass` - произвольное имя

const instance = new MyClass('Alice');
instance.sayHello(); // Hello, I'm Alice
```

#### 3. Импорт всего как объекта (Namespace Import)
Импортирует все именованные экспорты как свойства одного объекта.

```javascript
// app.js
import * as Utils from './utils.js';

console.log(Utils.PI); // 3.14159
console.log(Utils.sum(2, 2)); // 4

const calc = new Utils.Calculator();
console.log(calc.add(7, 3)); // 10
```

#### 4. Комбинированный импорт
Импорт по умолчанию вместе с именованными импортами:

```javascript
// app.js
import DefaultMessage, { config } from './combined.js';

console.log(DefaultMessage); // Это сообщение по умолчанию.
console.log(config.version); // 1.0.0
```

### Переэкспорт (Re-export)

Позволяет экспортировать сущности из другого модуля, не импортируя их явно в текущий. Удобно для создания "сборщиков" модулей (barrel files).

```javascript
// components/index.js (файл-сборщик)
export { sum, PI } from './utils.js';
export { default as MyClass } from './myModule.js'; // Переэкспортируем дефолт как именованный
// Или все именованные экспорты из файла:
// export * from './another-utils.js';
```

Теперь из `app.js` можно импортировать так:

```javascript
// app.js
import { sum, PI, MyClass } from './components/index.js';

console.log(sum(PI, 1));
const myInstance = new MyClass('Bob');
myInstance.sayHello();
```

### Динамические импорты (`import()`)

Позволяют загружать модули асинхронно, во время выполнения, а не на старте приложения. Возвращают промис, который разрешается в объект модуля.

```javascript
// app.js
const loadAndUseModule = async () => {
  // Например, загружаем модуль только при клике на кнопку или в зависимости от роута
  if (true /* какое-то условие */) {
    const { sum, PI } = await import('./utils.js');
    console.log(`Динамический импорт: ${sum(PI, 1)}`);
  }
};

loadAndUseModule(); // Вызовем для примера
```
Полезно для "ленивой" загрузки частей приложения (code splitting) и улучшения производительности.

### Практика и советы

*   **Расширение файлов:** В браузерах и Node.js (когда тип модуля `module` в `package.json` или `.mjs` расширение) требуется указывать полное расширение файла `.js` (или `.mjs`) при импорте.
*   **Относительные/абсолютные пути:** Используйте относительные пути (начинаются с `./` или `../`) для ваших модулей. Для библиотек из `node_modules` можно использовать голые имена (например, `import React from 'react';`).
*   **Transpilation/Bundling:** Хотя ES6 модули являются стандартом, для широкой поддержки в старых браузерах и для оптимизации (tree-shaking, code splitting) часто используются инструменты вроде Webpack, Rollup или Parcel.
*   **Top-Level `await`:** В ES модулях можно использовать `await` на верхнем уровне файла без оборачивания его в асинхронную функцию. Это удобно, например, для инициализации модуля, зависящей от асинхронных операций.

```javascript
// configLoader.js
// Предположим, что someAsyncConfig() возвращает промис с конфигурацией
export const config = await someAsyncConfig();
```

---

**Задание:**
Создайте два файла: `mathOperations.js` и `main.js`.
1.  В `mathOperations.js`:
    *   Экспортируйте именованную функцию `multiply(a, b)`.
    *   Экспортируйте именованную константу `E = 2.71828`.
    *   Экспортируйте по умолчанию класс `Calculator`, который имеет метод `divide(a, b)`.
2.  В `main.js`:
    *   Импортируйте все из `mathOperations.js` как `MathUtils` (namespace import).
    *   Импортируйте `Calculator` по умолчанию как `MyCalculator`.
    *   Используйте `multiply`, `E` и `divide` для вывода результатов в консоль.
### Практика

Попробуйте примеры в интерактивном редакторе:

<Playground template="vanilla" />
