## JavaScript: Стрелочные vs Обычные Функции


![Иллюстрация к уроку](/lessons/javascript-arrow-vs-regular.png)
Функции – фундаментальный строительный блок JavaScript. В этом уроке мы разберем два основных типа функций: обычные функции и стрелочные функции, изучим их различия и научимся выбирать подходящий тип для конкретной задачи.

### Обычные Функции

Обычные функции объявляются с использованием ключевого слова `function`. Они обладают гибкостью и имеют доступ к специальному объекту `this`, контекст которого определяется тем, как функция была вызвана.

```javascript
function greet(name) {
  console.log("Привет, " + name + "!");
}

greet("Мир"); // Вывод: Привет, Мир!
```

Внутри обычной функции `this` может ссылаться на разные вещи, в зависимости от контекста вызова. Например, если функция является методом объекта, то `this` будет ссылаться на этот объект.

```javascript
const person = {
  name: "Иван",
  greet: function() {
    console.log("Привет, " + this.name + "!");
  }
};

person.greet(); // Вывод: Привет, Иван!
```

### Стрелочные Функции

Стрелочные функции – это более компактный синтаксис для написания функций. Они были введены в ES6 (ECMAScript 2015).

```javascript
const greetArrow = (name) => {
  console.log("Привет, " + name + "!");
};

greetArrow("Вселенная"); // Вывод: Привет, Вселенная!
```

Если функция содержит только одно выражение, можно опустить фигурные скобки и `return`:

```javascript
const square = (x) => x * x;

console.log(square(5)); // Вывод: 25
```

**Ключевое отличие:** Стрелочные функции *не имеют* собственного `this`. Они наследуют `this` от окружающего контекста (лексический `this`). Это делает их удобными для использования внутри других функций, где требуется доступ к `this` внешней функции.

```javascript
const person = {
  name: "Елена",
  greet: function() {
    setTimeout(() => {
      console.log("Привет, " + this.name + "!"); // this ссылается на person
    }, 1000);
  }
};

person.greet(); // Вывод: Привет, Елена! (через 1 секунду)
```

В этом примере, если бы мы использовали обычную функцию внутри `setTimeout`, нам бы пришлось использовать `bind` или сохранять `this` во временную переменную, чтобы получить доступ к `person.name`. Стрелочная функция избавляет нас от этой необходимости.

### Жизненный пример

В React стрелочные функции часто используются для обработчиков событий:

```javascript
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.state = { count: 0 };
    this.handleClick = this.handleClick.bind(this); // Не нужно, если используем стрелочную функцию
  }

  handleClick = () => { // Стрелочная функция
    this.setState({ count: this.state.count + 1 });
  }

  render() {
    return (
      <button onClick={this.handleClick}>
        Увеличить: {this.state.count}
      </button>
    );
  }
}
```

Использование стрелочной функции позволяет избежать необходимости привязывать контекст (`this`) к методу `handleClick` в конструкторе.  В библиотеках, активно использующих коллбэки (например, работа с AJAX), стрелочные функции упрощают код и делают его более читабельным.

### Ключевые моменты

*   **Синтаксис:** Стрелочные функции предлагают более короткий синтаксис.
*   **`this`:** Стрелочные функции не имеют собственного `this`, а наследуют его из окружающего контекста. Обычные функции определяют `this` в зависимости от вызова.
*   **`arguments`:** Стрелочные функции не имеют объекта `arguments`.
*   **Использование:** Стрелочные функции идеально подходят для коротких функций, особенно внутри других функций, где требуется доступ к `this` внешней функции. Обычные функции подходят для создания методов объектов и функций, где требуется гибкое управление контекстом `this`.
*   **Конструктор:** Стрелочные функции не могут быть использованы как конструкторы (нельзя использовать `new` с ними).



## Интерактивный пример

<Sandpack
  template="vanilla"
  files={{
    "/index.html": `<!DOCTYPE html>
<html>
<head>
  <title>Стрелочные vs Обычные Функции</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <h1>Стрелочные vs Обычные Функции</h1>

  <div id="app">
    <button id="regularButton">Обычная функция: 0</button>
    <button id="arrowButton">Стрелочная функция: 0</button>
    <p>Введите имя:</p>
    <input type="text" id="nameInput" value="Мир">
    <button id="greetButton">Поздороваться</button>
    <p id="greetingOutput"></p>
  </div>

  <script src="index.js"><\/script>
</body>
</html>`,
    "/styles.css": `body {
  font-family: sans-serif;
  background-color: #222;
  color: #eee;
  padding: 20px;
}

#app {
  background-color: #333;
  padding: 20px;
  border-radius: 5px;
}

button {
  background-color: #4CAF50; /* Green */
  border: none;
  color: white;
  padding: 10px 20px;
  text-align: center;
  text-decoration: none;
  display: inline-block;
  font-size: 16px;
  margin: 4px 2px;
  cursor: pointer;
  border-radius: 5px;
}

input[type=text] {
  padding: 10px;
  margin: 5px;
  border: 1px solid #ccc;
  border-radius: 4px;
  box-sizing: border-box;
  background-color: #444;
  color: #eee;
}

p {
  margin-top: 10px;
}`,
    "/index.js": `// Обычная функция
let regularCount = 0;
const regularButton = document.getElementById('regularButton');

regularButton.addEventListener('click', function() {
  regularCount++;
  this.textContent = 'Обычная функция: ' + regularCount; // 'this' ссылается на кнопку
});

// Стрелочная функция
let arrowCount = 0;
const arrowButton = document.getElementById('arrowButton');

arrowButton.addEventListener('click', () => {
  arrowCount++;
  arrowButton.textContent = 'Стрелочная функция: ' + arrowCount; // Не нужно bind(this), так как 'this' берется из контекста
});

// Пример с приветствием
const nameInput = document.getElementById('nameInput');
const greetButton = document.getElementById('greetButton');
const greetingOutput = document.getElementById('greetingOutput');

const greetRegular = function(name) {
  return "Привет, " + name + "!";
};

const greetArrow = (name) => "Привет, " + name + "!";

greetButton.addEventListener('click', () => {
  const name = nameInput.value;
  greetingOutput.textContent = greetArrow(name); // Используем стрелочную функцию для приветствия
});
`
  }}
  options={{
    showNavigator: false,
    showLineNumbers: true,
    editorHeight: 400
  }}
/>
