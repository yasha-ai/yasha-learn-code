## JavaScript: События в браузере и JS

События — это сигналы от браузера о том, что что-то произошло. Это могут быть действия пользователя (клик, ввод с клавиатуры, прокрутка) или изменения в самом браузере (загрузка страницы, изменение размера окна). JavaScript позволяет нам "слушать" эти события и реагировать на них.

### Основы работы с событиями

Самый распространенный способ регистрации обработчика событий — это метод `addEventListener()`.

```javascript
// 1. Находим элемент, за которым хотим наблюдать
const myButton = document.querySelector('#myButton');

// 2. Добавляем слушателя события 'click'
// Первый аргумент: тип события (строка)
// Второй аргумент: функция-обработчик, которая будет вызвана при событии
myButton.addEventListener('click', () => {
  console.log('Кнопка была нажата!');
  alert('Привет из обработчика события!');
});

// HTML: <button id="myButton">Нажми меня</button>
```

#### Объект события (Event Object)

Когда происходит событие, браузер передает в нашу функцию-обработчик специальный объект `Event`. Он содержит много полезной информации о произошедшем событии.

```javascript
const myInput = document.querySelector('#myInput');

myInput.addEventListener('input', (event) => {
  // Деструктуризация для удобного доступа к свойствам объекта event
  const { target, type, data } = event; 
  
  console.log(`Тип события: ${type}`); // 'input'
  console.log(`Элемент, вызвавший событие:`, target); // <input id="myInput">
  console.log(`Текущее значение поля: ${target.value}`); // Актуальное значение
  console.log(`Введенный символ (для 'input', 'keydown' и т.п.):`, data); // Если применимо
});

// HTML: <input type="text" id="myInput" placeholder="Введи что-нибудь">
```

### Распространение событий (Event Propagation)

События не просто возникают в одном месте. Они "путешествуют" по DOM-дереву. Этот процесс называется распространением событий и имеет две фазы:

1.  **Захват (Capturing)**: Событие сначала движется от `window` вниз к целевому элементу.
2.  **Всплытие (Bubbling)**: После достижения целевого элемента событие начинает "всплывать" обратно вверх по дереву к `window`.

По умолчанию `addEventListener` регистрирует обработчики на фазе всплытия.

```javascript
const parentDiv = document.querySelector('#parent');
const childButton = document.querySelector('#child');

parentDiv.addEventListener('click', () => {
  console.log('Клик на родителе!');
});

childButton.addEventListener('click', () => {
  console.log('Клик на дочернем элементе!');
});

// При клике на дочерней кнопке сначала сработает 'Клик на дочернем элементе!',
// затем 'Клик на родителе!' из-за всплытия.

// HTML:
// <div id="parent" style="padding: 20px; border: 1px solid blue;">
//   Родитель
//   <button id="child">Дочерняя кнопка</button>
// </div>
```

#### `event.stopPropagation()` и `event.preventDefault()`

*   `event.stopPropagation()`: Останавливает дальнейшее распространение события по DOM-дереву (т.е. всплытие или захват).
*   `event.preventDefault()`: Отменяет стандартное действие браузера, связанное с событием. Например, переход по ссылке при клике на `<a>`, или отправку формы при клике на `<button type="submit">`.

```javascript
const myLink = document.querySelector('#myLink');
const stopButton = document.querySelector('#stopButton');

myLink.addEventListener('click', (e) => {
  e.preventDefault(); // Запрещаем переход по ссылке
  console.log('Переход по ссылке отменен!');
});

stopButton.addEventListener('click', (e) => {
  e.stopPropagation(); // Останавливаем всплытие
  console.log('Клик на кнопке, всплытие остановлено!');
});

document.body.addEventListener('click', () => {
  console.log('Клик на Body!'); // Сработает при клике на myLink, но не на stopButton
});

// HTML:
// <a href="https://example.com" id="myLink">Не переходи!</a>
// <button id="stopButton">Кликни и останови всплытие</button>
```

### Контекст `this` и стрелочные функции

В обычной функции-обработчике событий ключевое слово `this` по умолчанию указывает на элемент, на котором установлен слушатель. Однако, внутри стрелочных функций `this` сохраняет контекст из места, где функция была определена (лексический `this`), что часто является более предсказуемым поведением.

```javascript
const buttonWithThis = document.querySelector('#buttonThis');

// Обычная функция: 'this' будет указывать на buttonWithThis
buttonWithThis.addEventListener('click', function() {
  console.log('Обычная функция, this:', this.id); // buttonThis
  this.style.backgroundColor = 'red';
});

// Стрелочная функция: 'this' будет указывать на window (или undefined в строгом режиме)
// Если нам не нужен 'this', связанный с элементом, стрелочные функции безопаснее
buttonWithThis.addEventListener('mouseover', (e) => {
  console.log('Стрелочная функция, this:', this); // window (или другой внешний контекст)
  e.target.style.cursor = 'pointer'; // Доступ к элементу через e.target
});

// HTML: <button id="buttonThis">Тест this</button>
```

### Продвинутое использование: Делегирование событий

Вместо того чтобы добавлять слушатель к каждому элементу в списке, мы можем добавить один слушатель к их общему родителю. Когда событие всплывает, мы проверяем `event.target`, чтобы определить, на каком дочернем элементе произошел клик. Это эффективно для списков и динамически добавляемых элементов.

```javascript
const list = document.querySelector('#myList');

list.addEventListener('click', (e) => {
  // Проверяем, был ли клик именно по элементу <li> внутри списка
  if (e.target.tagName === 'LI') {
    console.log(`Кликнули на элементе списка: ${e.target.textContent}`);
    e.target.style.backgroundColor = 'yellow';
  }
});

// HTML:
// <ul id="myList">
//   <li>Пункт 1</li>
//   <li>Пункт 2</li>
//   <li>Пункт 3</li>
// </ul>
```

### Типичные ошибки и советы

1.  **Забыли `preventDefault`**: Особенно актуально для форм (`submit`) и ссылок (`click`). Если не отменить дефолтное поведение, страница может перезагрузиться или перейти по ссылке, потеряв состояние вашего приложения.
2.  **Проблемы с контекстом `this`**: Если вам нужен доступ к элементу-источнику события, используйте `event.target` или `event.currentTarget` (если нужно получить элемент, на котором висит слушатель), либо будьте внимательны с `this` в обычных функциях. Стрелочные функции помогут избежать неожиданного `this`.
3.  **Не удалили слушателя**: Если вы добавляете слушатели к элементам, которые потом удаляются из DOM, и не убираете слушатели (`removeEventListener`), это может привести к утечкам памяти.

### Практика

Создайте на странице две кнопки. При нажатии на первую кнопку, она должна менять свой текст на "Нажато!" и становиться неактивной. При нажатии на вторую кнопку, она должна выводить в консоль текущее время и дату, но при этом запретить любое всплытие события клика.