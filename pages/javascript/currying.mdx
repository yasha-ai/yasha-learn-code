## JavaScript: Мозги. Урок: Каррирование и частичное применение


![Иллюстрация к уроку](/lessons/javascript-currying.png)
Каррирование и частичное применение – мощные техники функционального программирования, позволяющие создавать более гибкий и переиспользуемый код. Они позволяют "зафиксировать" часть аргументов функции, создавая новые функции с меньшей арностью (количеством ожидаемых аргументов).

### Что такое каррирование?

Каррирование – это преобразование функции, принимающей несколько аргументов, в последовательность функций, каждая из которых принимает только один аргумент.  Каждая функция возвращает другую функцию, ожидающую следующий аргумент, и так до тех пор, пока не будут переданы все аргументы, после чего возвращается результат.

```javascript
// Функция, принимающая два аргумента
function add(x, y) {
  return x + y;
}

// Каррированная версия функции add
function curriedAdd(x) {
  return function(y) {
    return x + y;
  };
}

// Использование
const add5 = curriedAdd(5); // add5 теперь функция, ожидающая один аргумент
console.log(add5(3)); // Выводит 8
console.log(curriedAdd(10)(2)); // Выводит 12
```

### Что такое частичное применение?

Частичное применение – это процесс, когда мы заранее предоставляем часть аргументов функции, создавая новую функцию с меньшим количеством необходимых аргументов.  В отличие от каррирования, частичное применение не обязательно преобразует функцию в последовательность функций, принимающих по одному аргументу.

```javascript
function greet(greeting, name) {
  return `${greeting}, ${name}!`;
}

// Частичное применение с использованием bind
const sayHello = greet.bind(null, "Hello"); // "Hello" зафиксирован как первый аргумент

console.log(sayHello("Alice")); // Выводит "Hello, Alice!"
console.log(sayHello("Bob"));   // Выводит "Hello, Bob!"

// Частичное применение без bind
function partialGreet(greeting) {
  return function(name) {
    return `${greeting}, ${name}!`;
  }
}

const sayGoodMorning = partialGreet("Good morning");
console.log(sayGoodMorning("Eve")); // Выводит "Good morning, Eve!"
```

### Практические примеры кода

```javascript
// Пример: функция для создания тегов HTML
function createTag(tag, attributes, content) {
  let attrString = "";
  for (const key in attributes) {
    attrString += ` ${key}="${attributes[key]}"`;
  }
  return `<${tag}${attrString}>${content}</${tag}>`;
}

// Каррированная версия
function curriedCreateTag(tag) {
  return function(attributes) {
    return function(content) {
      let attrString = "";
      for (const key in attributes) {
        attrString += ` ${key}="${attributes[key]}"`;
      }
      return `<${tag}${attrString}>${content}</${tag}>`;
    };
  };
}

const createDiv = curriedCreateTag("div");
const divWithClass = createDiv({ class: "container" });
console.log(divWithClass("Hello, world!")); // Выводит <div class="container">Hello, world!</div>

// Пример: частичное применение с bind для валидации
function validateInput(validator, input) {
  return validator(input);
}

function isEmailValid(email) {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
}

const validateEmail = validateInput.bind(null, isEmailValid);

console.log(validateEmail("test@example.com")); // Выводит true
console.log(validateEmail("invalid-email"));    // Выводит false
```

### Жизненный пример

Во фреймворке React, каррирование и частичное применение часто используются при работе с компонентами высшего порядка (Higher-Order Components - HOC). HOC позволяют обернуть компонент для добавления дополнительной функциональности, например, авторизации или логирования.  Частичное применение позволяет передавать параметры в HOC, создавая кастомизированные обертки для компонентов.

В Redux, `connect` функция использует частичное применение для связывания состояния Redux с компонентами React.  `connect` принимает `mapStateToProps` и `mapDispatchToProps` как аргументы и возвращает новую функцию, которая, в свою очередь, принимает компонент React для обертывания.

### Ключевые моменты

*   Каррирование преобразует функцию с несколькими аргументами в последовательность функций с одним аргументом.
*   Частичное применение позволяет "зафиксировать" часть аргументов функции.
*   `bind` – удобный метод для частичного применения в JavaScript.
*   Эти техники повышают переиспользуемость и читаемость кода.
*   Часто используются во фреймворках React и Redux.



## Интерактивный пример

<Sandpack
  template="vanilla"
  files={{
    "/index.html": `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Каррирование и частичное применение</title>
  <link rel="stylesheet" href="/styles.css">
</head>
<body>
  <div class="container">
    <h1>Каррирование и частичное применение</h1>

    <div id="currying-example">
      <h2>Каррирование</h2>
      <label for="x-input">X:</label>
      <input type="number" id="x-input" value="5">
      <label for="y-input">Y:</label>
      <input type="number" id="y-input" value="3">
      <button id="curry-button">Вычислить (каррирование)</button>
      <p id="curry-result">Результат: </p>
    </div>

    <div id="partial-application-example">
      <h2>Частичное применение</h2>
      <label for="name-input">Имя:</label>
      <input type="text" id="name-input" value="Alice">
      <button id="partial-button">Поздороваться (частично)</button>
      <p id="partial-result">Приветствие: </p>
    </div>

    <div id="tag-example">
      <h2>Создание тегов (каррирование)</h2>
      <label for="content-input">Содержимое тега:</label>
      <input type="text" id="content-input" value="Hello, world!">
      <button id="tag-button">Создать DIV (каррирование)</button>
      <p id="tag-result">Результат: </p>
    </div>
  </div>

  <script src="/index.js"><\/script>
</body>
</html>`,
    "/styles.css": `body {
  font-family: sans-serif;
  background-color: #222;
  color: #eee;
  padding: 20px;
}

.container {
  max-width: 800px;
  margin: 0 auto;
}

input[type="number"], input[type="text"] {
  padding: 5px;
  margin: 5px;
  border: 1px solid #555;
  background-color: #333;
  color: #eee;
}

button {
  padding: 5px 10px;
  background-color: #444;
  color: #eee;
  border: none;
  cursor: pointer;
  margin: 5px;
}

button:hover {
  background-color: #555;
}

#curry-result, #partial-result, #tag-result {
  margin-top: 10px;
  font-weight: bold;
}`,
    "/index.js": `// Каррирование
function curriedAdd(x) {
  return function(y) {
    return x + y;
  };
}

const xInput = document.getElementById("x-input");
const yInput = document.getElementById("y-input");
const curryButton = document.getElementById("curry-button");
const curryResult = document.getElementById("curry-result");

curryButton.addEventListener("click", () => {
  const x = parseInt(xInput.value);
  const y = parseInt(yInput.value);
  const add5 = curriedAdd(x); // add5 теперь функция, ожидающая один аргумент
  const result = add5(y);
  curryResult.textContent = \`Результат: \${'}result'}\`;
});

// Частичное применение
function greet(greeting, name) {
  return \`\${'}greeting'}, \${'}name'}!\`;
}

const nameInput = document.getElementById("name-input");
const partialButton = document.getElementById("partial-button");
const partialResult = document.getElementById("partial-result");

const sayHello = greet.bind(null, "Hello"); // "Hello" зафиксирован как первый аргумент

partialButton.addEventListener("click", () => {
  const name = nameInput.value;
  const greeting = sayHello(name);
  partialResult.textContent = \`Приветствие: \${'}greeting'}\`;
});

// Каррирование для создания тегов
function curriedCreateTag(tag) {
  return function(attributes) {
    return function(content) {
      let attrString = "";
      for (const key in attributes) {
        attrString += \` \${'}key'}="\${'}attributes[key]'}"\`;
      }
      return \`<\${'}tag'}\${'}attrString'}>\${'}content'}</\${'}tag'}>\`;
    };
  };
}

const contentInput = document.getElementById("content-input");
const tagButton = document.getElementById("tag-button");
const tagResult = document.getElementById("tag-result");

tagButton.addEventListener("click", () => {
  const content = contentInput.value;
  const createDiv = curriedCreateTag("div");
  const divWithClass = createDiv({ class: "container" });
  const tag = divWithClass(content);
  tagResult.textContent = \`Результат: \${'}tag'}\`;
});
`
  }}
  options={{
    showNavigator: false,
    showLineNumbers: true,
    editorHeight: 400
  }}
/>
