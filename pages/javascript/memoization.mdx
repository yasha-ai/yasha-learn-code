# JavaScript: Мозги. Урок: Мемоизация


![Иллюстрация к уроку](/lessons/javascript-memoization.png)
Мемоизация – мощный метод оптимизации, который позволяет значительно ускорить выполнение ресурсоемких функций. Она основана на запоминании результатов вычислений и их переиспользовании при повторных вызовах с теми же аргументами.

## Что такое мемоизация?

Мемоизация – это техника оптимизации, при которой результаты вызовов функций, принимающих определенные аргументы, кэшируются. Когда функция вызывается снова с теми же аргументами, вместо повторного вычисления возвращается сохраненный результат. Это особенно полезно для функций, которые являются ресурсоемкими (например, выполняют сложные вычисления или запросы к API) и часто вызываются с одинаковыми входными данными.

### Пример простой мемоизации

Предположим, у нас есть функция, вычисляющая n-ое число Фибоначчи:

```javascript
function fibonacci(n) {
  if (n <= 1) {
    return n;
  }
  return fibonacci(n - 1) + fibonacci(n - 2);
}

console.log(fibonacci(5)); // 5
console.log(fibonacci(6)); // 8
```

Эта функция очень неэффективна, потому что она многократно вычисляет одни и те же значения. Мемоизация может помочь это исправить:

```javascript
function memoizeFibonacci() {
  const cache = {}; // Создаем кэш для хранения результатов

  return function fibonacci(n) {
    if (n in cache) { // Проверяем, есть ли результат в кэше
      return cache[n]; // Если есть, возвращаем его
    }

    if (n <= 1) {
      return n;
    }

    const result = fibonacci(n - 1) + fibonacci(n - 2); // Вычисляем результат
    cache[n] = result; // Сохраняем результат в кэш
    return result; // Возвращаем результат
  };
}

const memoFib = memoizeFibonacci();

console.log(memoFib(5)); // 5
console.log(memoFib(6)); // 8
```

В этом примере `memoizeFibonacci` возвращает функцию `fibonacci`, которая имеет доступ к переменной `cache`. При каждом вызове `fibonacci` сначала проверяет, есть ли результат для данного `n` в `cache`. Если есть, он возвращает сохраненный результат. В противном случае он вычисляет результат, сохраняет его в `cache` и возвращает.

### Универсальная функция мемоизации

Можно создать универсальную функцию мемоизации, которая может быть применена к любой другой функции:

```javascript
function memoize(func) {
  const cache = {};
  return function(...args) {
    const key = JSON.stringify(args); // Преобразуем аргументы в строку для использования в качестве ключа
    if (cache[key]) {
      return cache[key];
    }
    const result = func(...args);
    cache[key] = result;
    return result;
  };
}

function expensiveFunction(a, b) {
  console.log("Выполняю сложное вычисление...");
  return a + b;
}

const memoizedExpensiveFunction = memoize(expensiveFunction);

console.log(memoizedExpensiveFunction(2, 3)); // Выполняю сложное вычисление... 5
console.log(memoizedExpensiveFunction(2, 3)); // 5 (берется из кэша)
console.log(memoizedExpensiveFunction(4, 5)); // Выполняю сложное вычисление... 9
```

## Жизненный пример

Мемоизация широко используется в различных библиотеках и фреймворках JavaScript.

*   **React:**  Компонент `React.memo` использует мемоизацию для предотвращения ненужных перерисовок компонентов. Он сравнивает пропсы (props) компонента и, если они не изменились, не перерисовывает компонент, а использует ранее отрендеренный результат.
*   **Redux:**  Функция `createSelector` из библиотеки `reselect` использует мемоизацию для оптимизации вычислений, основанных на состоянии Redux. Она пересчитывает результат только тогда, когда изменяются входные селекторы.
*   **lodash:** Библиотека lodash предоставляет функцию `_.memoize`, которая реализует мемоизацию.

## Ключевые моменты

*   Мемоизация – это техника оптимизации для ресурсоемких функций.
*   Результаты вызовов функций кэшируются для последующего переиспользования.
*   Мемоизация может значительно улучшить производительность, особенно при частом вызове функций с одинаковыми аргументами.
*   Важно учитывать, что мемоизация требует дополнительной памяти для хранения кэшированных результатов.
*   Универсальные функции мемоизации позволяют применять эту технику к различным функциям.
*   Мемоизация широко используется в различных JavaScript библиотеках и фреймворках.



## Интерактивный пример

<Sandpack
  template="vanilla"
  files={{
    "/index.html": `<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Мемоизация</title>
  <link rel="stylesheet" href="/styles.css">
</head>
<body>
  <div class="container">
    <h1>Мемоизация чисел Фибоначчи</h1>
    <label for="fibonacci-input">Введите число n:</label>
    <input type="number" id="fibonacci-input" value="10">
    <button id="calculate-button">Вычислить</button>
    <p>Результат: <span id="fibonacci-result"></span></p>
    <p>Вычислений (без мемоизации): <span id="fibonacci-count">0</span></p>
    <p>Результат (с мемоизацией): <span id="memo-fibonacci-result"></span></p>
    <p>Вычислений (с мемоизацией): <span id="memo-fibonacci-count">0</span></p>
  </div>
  <script src="/index.js"><\/script>
</body>
</html>`,
    "/styles.css": `body {
  font-family: sans-serif;
  background-color: #222;
  color: #eee;
  padding: 20px;
}

.container {
  max-width: 600px;
  margin: 0 auto;
  background-color: #333;
  padding: 20px;
  border-radius: 8px;
}

label {
  display: block;
  margin-bottom: 5px;
}

input[type="number"] {
  padding: 8px;
  border: 1px solid #555;
  border-radius: 4px;
  background-color: #444;
  color: #eee;
  width: 100%;
  margin-bottom: 10px;
}

button {
  padding: 10px 15px;
  background-color: #4CAF50;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

button:hover {
  background-color: #367c39;
}

p {
  margin-bottom: 8px;
}`,
    "/index.js": `// Функция для вычисления чисел Фибоначчи (без мемоизации)
let fibonacciCount = 0;
function fibonacci(n) {
  fibonacciCount++;
  if (n <= 1) {
    return n;
  }
  return fibonacci(n - 1) + fibonacci(n - 2);
}

// Функция для мемоизации
function memoize(func) {
  const cache = {};
  return function(...args) {
    const key = String(args); // Преобразуем аргументы в строку для использования в качестве ключа
    if (cache[key]) {
      return cache[key];
    }
    const result = func(...args);
    cache[key] = result;
    return result;
  };
}

// Мемоизированная функция Фибоначчи
let memoFibonacciCount = 0;
const memoizedFibonacci = memoize(function fib(n) {
  memoFibonacciCount++;
  if (n <= 1) {
    return n;
  }
  return fib(n - 1) + fib(n - 2);
});

// Получаем элементы DOM
const fibonacciInput = document.getElementById('fibonacci-input');
const calculateButton = document.getElementById('calculate-button');
const fibonacciResult = document.getElementById('fibonacci-result');
const fibonacciCountElement = document.getElementById('fibonacci-count');
const memoFibonacciResult = document.getElementById('memo-fibonacci-result');
const memoFibonacciCountElement = document.getElementById('memo-fibonacci-count');

// Обработчик события для кнопки
calculateButton.addEventListener('click', () => {
  const n = parseInt(fibonacciInput.value);

  // Вычисляем и отображаем результат без мемоизации
  fibonacciCount = 0;
  const result = fibonacci(n);
  fibonacciResult.textContent = result;
  fibonacciCountElement.textContent = fibonacciCount;

  // Вычисляем и отображаем результат с мемоизацией
  memoFibonacciCount = 0;
  const memoResult = memoizedFibonacci(n);
  memoFibonacciResult.textContent = memoResult;
  memoFibonacciCountElement.textContent = memoFibonacciCount;
});`
  }}
  options={{
    showNavigator: false,
    showLineNumbers: true,
    editorHeight: 400
  }}
/>
