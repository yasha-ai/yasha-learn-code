import { Sandpack } from '@codesandbox/sandpack-react'

```markdown
# JavaScript: Мозги. Урок: map, filter, reduce детально

Добро пожаловать! Сегодня мы разберем три мощных метода массивов в JavaScript: `map`, `filter` и `reduce`. Они позволяют элегантно и эффективно преобразовывать и обрабатывать данные.

## map: Преобразование каждого элемента

Метод `map` создает *новый* массив, применяя функцию к *каждому* элементу исходного массива. Представьте, что у вас есть конвейер, где каждый элемент массива проходит через станцию обработки (вашу функцию) и выходит уже измененным.

```javascript
const numbers = [1, 2, 3, 4, 5];

// Увеличиваем каждый элемент массива на 2
const doubledNumbers = numbers.map(function(number) {
  return number * 2;
});

console.log(doubledNumbers); // Output: [2, 4, 6, 8, 10]
console.log(numbers); // Output: [1, 2, 3, 4, 5] (Исходный массив не изменился!)
```

Здесь `numbers.map(...)` применяет анонимную функцию `function(number) { return number * 2; }` к каждому числу в массиве `numbers`. Результат - новый массив `doubledNumbers` с удвоенными значениями.  Обратите внимание, что исходный массив `numbers` остался без изменений.

## filter: Отбор нужных элементов

Метод `filter` создает *новый* массив, содержащий только те элементы исходного массива, для которых функция-условие вернула `true`.  Это как сито, которое пропускает только то, что соответствует критериям.

```javascript
const numbers = [1, 2, 3, 4, 5, 6];

// Отбираем только четные числа
const evenNumbers = numbers.filter(function(number) {
  return number % 2 === 0;
});

console.log(evenNumbers); // Output: [2, 4, 6]
console.log(numbers); // Output: [1, 2, 3, 4, 5, 6] (Исходный массив не изменился!)
```

В этом примере `numbers.filter(...)` применяет функцию `function(number) { return number % 2 === 0; }` к каждому числу.  Если число четное (остаток от деления на 2 равен 0), то функция возвращает `true`, и число попадает в новый массив `evenNumbers`.

## reduce: Сведение массива к одному значению

Метод `reduce` сводит массив к одному значению (числу, строке, объекту и т.д.), последовательно применяя функцию к каждому элементу и аккумулятору (значению, полученному на предыдущем шаге). Это как калькулятор, который последовательно применяет операцию к числам и накапливает результат.

```javascript
const numbers = [1, 2, 3, 4, 5];

// Суммируем все элементы массива
const sum = numbers.reduce(function(accumulator, currentValue) {
  return accumulator + currentValue;
}, 0); // 0 - это начальное значение аккумулятора

console.log(sum); // Output: 15
console.log(numbers); // Output: [1, 2, 3, 4, 5] (Исходный массив не изменился!)
```

Здесь `numbers.reduce(...)` применяет функцию `function(accumulator, currentValue) { return accumulator + currentValue; }`.  `accumulator` - это текущая сумма (начинается с 0), а `currentValue` - текущий элемент массива. Функция возвращает сумму `accumulator` и `currentValue`, которая становится новым значением `accumulator` для следующей итерации.

## Жизненный пример

Представьте, что у вас есть список товаров в интернет-магазине.

*   **map**: Вы можете использовать `map` для отображения цены каждого товара в определенной валюте.
*   **filter**: Вы можете использовать `filter` для отображения только товаров, находящихся в наличии.
*   **reduce**: Вы можете использовать `reduce` для вычисления общей стоимости всех товаров в корзине.

В React, Vue и Angular эти методы активно используются для обработки данных, полученных с сервера, для рендеринга списков, фильтрации результатов поиска и агрегации данных. Например, в React:

```javascript
// Пример в React (псевдокод)
const products = [/* ... массив объектов продуктов ... */];

const availableProducts = products.filter(product => product.inStock);
const productNames = availableProducts.map(product => product.name);

return (
  <ul>
    {productNames.map(name => <li key={name}>{name}</li>)}
  </ul>
);
```

## Ключевые моменты

*   `map`, `filter` и `reduce` не изменяют исходный массив.
*   `map` создает новый массив с преобразованными элементами.
*   `filter` создает новый массив с отфильтрованными элементами.
*   `reduce` сводит массив к одному значению.
*   Эти методы часто используются вместе для решения сложных задач обработки данных.
*   Важно понимать, что каждый метод возвращает.
```
### Практика

Попробуйте примеры в интерактивном редакторе:

<Sandpack
  template="vanilla"
  files={{
    '/index.js': `// Демонстрация map, filter, reduce

document.body.style.fontFamily = 'Arial, sans-serif';
document.body.style.padding = '20px';
document.body.style.lineHeight = '1.6';

const products = [
  { name: 'Ноутбук', price: 50000, inStock: true },
  { name: 'Телефон', price: 30000, inStock: false },
  { name: 'Наушники', price: 5000, inStock: true },
  { name: 'Монитор', price: 20000, inStock: true },
  { name: 'Клавиатура', price: 3000, inStock: false }
];

// Показываем исходный массив
const h2 = document.createElement('h2');
h2.textContent = 'Исходные данные:';
document.body.appendChild(h2);

const originalList = document.createElement('ul');
products.forEach(p => {
  const li = document.createElement('li');
  li.textContent = \`\${p.name} - \${p.price} руб. \${p.inStock ? '✓' : '✗'}\`;
  originalList.appendChild(li);
});
document.body.appendChild(originalList);

// 1. MAP: Преобразование
const h3_1 = document.createElement('h3');
h3_1.textContent = '1. map() - Конвертация цены в доллары ($1 = 90₽)';
document.body.appendChild(h3_1);

const pricesInUSD = products.map(p => ({
  name: p.name,
  priceUSD: Math.round(p.price / 90)
}));

const mapList = document.createElement('ul');
pricesInUSD.forEach(p => {
  const li = document.createElement('li');
  li.textContent = \`\${p.name}: $\${p.priceUSD}\`;
  mapList.appendChild(li);
});
document.body.appendChild(mapList);

console.log('MAP результат:', pricesInUSD);

// 2. FILTER: Фильтрация
const h3_2 = document.createElement('h3');
h3_2.textContent = '2. filter() - Только товары в наличии';
document.body.appendChild(h3_2);

const available = products.filter(p => p.inStock);

const filterList = document.createElement('ul');
available.forEach(p => {
  const li = document.createElement('li');
  li.textContent = \`\${p.name} - \${p.price} руб.\`;
  li.style.color = '#4CAF50';
  filterList.appendChild(li);
});
document.body.appendChild(filterList);

console.log('FILTER результат:', available);

// 3. REDUCE: Агрегация
const h3_3 = document.createElement('h3');
h3_3.textContent = '3. reduce() - Общая стоимость товаров в наличии';
document.body.appendChild(h3_3);

const totalPrice = available.reduce((sum, product) => {
  return sum + product.price;
}, 0);

const resultDiv = document.createElement('div');
resultDiv.innerHTML = \`
  <p><strong>Товаров в наличии:</strong> \${available.length}</p>
  <p><strong>Общая стоимость:</strong> \${totalPrice.toLocaleString('ru-RU')} руб.</p>
\`;
resultDiv.style.backgroundColor = '#f0f0f0';
resultDiv.style.padding = '15px';
resultDiv.style.borderRadius = '5px';
document.body.appendChild(resultDiv);

console.log('REDUCE результат:', totalPrice);

// 4. Комбинация методов
const h3_4 = document.createElement('h3');
h3_4.textContent = '4. Комбинация: товары > 10000₽ в наличии';
document.body.appendChild(h3_4);

const expensiveAvailable = products
  .filter(p => p.inStock)
  .filter(p => p.price > 10000)
  .map(p => p.name);

const comboDiv = document.createElement('div');
comboDiv.innerHTML = \`<p>\${expensiveAvailable.join(', ')}</p>\`;
comboDiv.style.fontWeight = 'bold';
document.body.appendChild(comboDiv);

console.log('Комбинированный результат:', expensiveAvailable);`
  }}
/>
