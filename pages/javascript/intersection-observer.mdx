## JavaScript: Мозги. Урок: Intersection Observer


![Иллюстрация к уроку](/lessons/javascript-intersection-observer.png)
Intersection Observer API позволяет отслеживать, когда элемент становится видимым в окне браузера (viewport) или внутри другого элемента. Это мощный инструмент для оптимизации производительности и создания интерактивных пользовательских интерфейсов.

### Что такое Intersection Observer?

Представьте, что у вас есть охранник, который следит за конкретным объектом (элементом на странице). Как только часть этого объекта попадает в поле зрения охранника (viewport или другой элемент), охранник подает сигнал. Intersection Observer – это и есть этот охранник в мире JavaScript. Он асинхронно следит за пересечением целевого элемента с другим элементом (корнем или viewport).

### Практический пример кода

Давайте создадим простой пример, где мы будем добавлять класс `visible` к элементу, когда он становится видимым в viewport.

```html
<!DOCTYPE html>
<html>
<head>
  <title>Intersection Observer Example</title>
  <style>
    .box {
      width: 200px;
      height: 200px;
      background-color: lightblue;
      margin-bottom: 500px; /* Чтобы контент прокручивался */
    }

    .visible {
      background-color: lightgreen;
    }
  </style>
</head>
<body>
  <div class="box">Этот блок будет изменять цвет, когда станет видимым.</div>

  <script>
    const box = document.querySelector('.box');

    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          box.classList.add('visible');
          observer.unobserve(box); // Прекращаем наблюдение, когда элемент стал видимым
        } else {
          box.classList.remove('visible'); // Удаляем класс, если элемент снова невидим
        }
      });
    });

    observer.observe(box);
  </script>
</body>
</html>
```

В этом примере:

1.  Мы создаем новый `IntersectionObserver`.
2.  В колбэк-функции мы проверяем свойство `isIntersecting` каждого `entry`.  `isIntersecting` равно `true`, если элемент пересекается с viewport.
3.  Если элемент видим, мы добавляем класс `visible` и прекращаем наблюдение, чтобы не выполнять колбэк при каждом изменении видимости. Это оптимизация.
4.  Мы начинаем наблюдение за элементом `box` с помощью `observer.observe(box)`.

### Настройка параметров Intersection Observer

Мы можем настроить `IntersectionObserver`, передав ему объект с параметрами.

```javascript
const options = {
  root: null, // Элемент, относительно которого происходит пересечение (null = viewport)
  rootMargin: '0px', // Отступы вокруг root
  threshold: 0.5 // Порог видимости (0.0 - 1.0). 0.5 означает, что 50% элемента должны быть видны.
};

const observer = new IntersectionObserver((entries) => {
  // ...
}, options);
```

*   `root`: Определяет элемент, который используется как область просмотра для отслеживания видимости целевого элемента. Если указать `null` (значение по умолчанию), используется viewport браузера.
*   `rootMargin`: Добавляет отступы вокруг `root`.  Можно использовать значения в `px` или `%`. Например, `rootMargin: '100px 0px 100px 0px'` добавит отступы сверху и снизу в 100px.
*   `threshold`: Определяет, какой процент целевого элемента должен быть видим, чтобы колбэк был вызван. Значение от 0.0 до 1.0.

### Жизненный пример

Intersection Observer широко используется в реальных проектах для:

*   **Ленивой загрузки изображений:** Загрузка изображений только когда они становятся видимыми в viewport, что значительно улучшает производительность страницы.
*   **Реализации бесконечной прокрутки (infinite scroll):** Подгрузка новых данных по мере приближения к концу страницы.
*   **Анимации при прокрутке:** Запуск анимации, когда элемент появляется в viewport.
*   **Отслеживания видимости рекламы:** Для аналитики и показа рекламы только когда она видна пользователю.
*   Многие фреймворки и библиотеки используют Intersection Observer для оптимизации рендеринга компонентов. Например, React-lazyload использует его для ленивой загрузки компонентов.

### Ключевые моменты

*   Intersection Observer API предоставляет эффективный способ отслеживать видимость элементов.
*   Он работает асинхронно, что не блокирует основной поток выполнения JavaScript.
*   `root`, `rootMargin` и `threshold` позволяют гибко настраивать условия срабатывания колбэка.
*   Intersection Observer помогает оптимизировать производительность и создавать более интерактивные пользовательские интерфейсы.
*   Важно прекращать наблюдение за элементом, когда оно больше не требуется, чтобы избежать ненужных вызовов колбэка.



## Интерактивный пример

<Sandpack
  template="vanilla"
  files={{
    "/index.html": `<!DOCTYPE html>
<html>
<head>
  <title>Intersection Observer Example</title>
  <link rel="stylesheet" href="/styles.css">
</head>
<body>
  <h1>Intersection Observer Demo</h1>
  <div id="options">
    <label for="threshold">Threshold (0-1):</label>
    <input type="number" id="threshold" value="0.5" min="0" max="1" step="0.1">
    <button id="updateButton">Update Observer</button>
  </div>
  <div class="box" id="box1">Этот блок будет изменять цвет, когда станет видимым.</div>
  <div class="box" id="box2">Этот блок тоже будет изменять цвет.</div>
  <div class="box" id="box3">И этот!</div>

  <script src="/index.js"></script>
</body>
</html>
`,
    "/styles.css": `body {
  font-family: sans-serif;
  padding: 20px;
  background-color: #222;
  color: #eee;
}

.box {
  width: 200px;
  height: 200px;
  background-color: lightblue;
  margin-bottom: 500px; /* Чтобы контент прокручивался */
  display: flex;
  justify-content: center;
  align-items: center;
  color: black;
  font-weight: bold;
}

.visible {
  background-color: lightgreen;
}

#options {
  margin-bottom: 20px;
}

#options label {
  margin-right: 10px;
}
`,
    "/index.js": `// Получаем элементы DOM
const boxes = document.querySelectorAll('.box');
const thresholdInput = document.getElementById('threshold');
const updateButton = document.getElementById('updateButton');

// Функция для создания Intersection Observer
function createObserver(threshold) {
  return new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        entry.target.classList.add('visible');
        // Прекращаем наблюдение после первого пересечения
        // observer.unobserve(entry.target);
      } else {
        entry.target.classList.remove('visible');
      }
    });
  }, {
    root: null, // viewport
    rootMargin: '0px',
    threshold: threshold
  });
}

// Создаем начальный observer
let observer = createObserver(parseFloat(thresholdInput.value));

// Наблюдаем за каждым блоком
boxes.forEach(box => {
  observer.observe(box);
});

// Обработчик кнопки обновления
updateButton.addEventListener('click', () => {
  // Получаем новое значение threshold
  const newThreshold = parseFloat(thresholdInput.value);

  // Отключаем старый observer
  observer.disconnect();

  // Создаем новый observer с новым порогом
  observer = createObserver(newThreshold);

  // Начинаем наблюдение за элементами снова
  boxes.forEach(box => {
    observer.observe(box);
  });
});
`
  }}
  options={{
    showNavigator: false,
    showLineNumbers: true,
    editorHeight: 400
  }}
/>
