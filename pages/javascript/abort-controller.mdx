## JavaScript: AbortController - Контроль над асинхронностью


![Иллюстрация к уроку](/lessons/javascript-abort-controller.png)
В мире JavaScript, особенно при работе с асинхронными операциями, важно уметь их контролировать. `AbortController` предоставляет мощный механизм для отмены таких операций, например, HTTP-запросов или длительных вычислений.

### Что такое AbortController?

`AbortController` - это API в JavaScript, который позволяет вам отменять асинхронные операции.  Он состоит из двух частей: `AbortController` и `AbortSignal`. `AbortController` используется для создания сигнала отмены, а `AbortSignal` передается в асинхронную операцию, чтобы она могла при необходимости прерваться.

Представьте, что вы отправили запрос на сервер, но пользователь решил перейти на другую страницу до получения ответа. Без `AbortController` браузер все равно будет ждать ответа, что неэффективно.

### Пример использования

```javascript
// 1. Создаем экземпляр AbortController
const controller = new AbortController();
// 2. Получаем AbortSignal
const signal = controller.signal;

// Функция для выполнения асинхронной операции (например, fetch)
async function fetchData() {
  try {
    const response = await fetch('https://api.example.com/data', { signal }); // Передаем signal в fetch
    const data = await response.json();
    console.log('Данные:', data);
  } catch (error) {
    if (error.name === 'AbortError') {
      console.log('Запрос отменен!');
    } else {
      console.error('Ошибка:', error);
    }
  }
}

// Запускаем асинхронную операцию
fetchData();

// 3. Отменяем запрос (например, при клике на кнопку)
setTimeout(() => {
  controller.abort(); // Отменяем запрос через 1 секунду
}, 1000);
```

В этом примере мы создаем `AbortController` и передаем его `signal` в функцию `fetch`. Через секунду мы вызываем `controller.abort()`, что приводит к отмене запроса.  `fetch` выбрасывает `AbortError`, который мы обрабатываем в блоке `catch`.

### Более сложный пример с UI

```html
<button id="fetchButton">Получить данные</button>
<button id="cancelButton">Отменить</button>
<div id="dataContainer"></div>

<script>
  const fetchButton = document.getElementById('fetchButton');
  const cancelButton = document.getElementById('cancelButton');
  const dataContainer = document.getElementById('dataContainer');

  let controller = null;

  fetchButton.addEventListener('click', async () => {
    controller = new AbortController();
    const signal = controller.signal;

    try {
      const response = await fetch('https://api.example.com/data', { signal });
      const data = await response.json();
      dataContainer.textContent = JSON.stringify(data);
    } catch (error) {
      if (error.name === 'AbortError') {
        dataContainer.textContent = 'Запрос отменен пользователем.';
      } else {
        dataContainer.textContent = 'Произошла ошибка: ' + error;
      }
    }
  });

  cancelButton.addEventListener('click', () => {
    if (controller) {
      controller.abort();
      controller = null; // Сбрасываем контроллер
    }
  });
</script>
```

Этот пример демонстрирует, как `AbortController` можно использовать для отмены запроса по нажатию кнопки.  Важно сбрасывать `controller` после отмены, чтобы при следующем нажатии кнопки "Получить данные" создавался новый `AbortController`.

### Жизненный пример

`AbortController` широко используется во фреймворках, таких как React и Vue, для управления асинхронными операциями в компонентах. Например, при переключении между маршрутами или при размонтировании компонента, можно отменить все незавершенные HTTP-запросы, чтобы избежать утечек памяти и нежелательных побочных эффектов.  Также, он используется в библиотеках для работы с сетью, например, `axios`, для предоставления пользователю возможности отменять запросы.

### Ключевые моменты

*   `AbortController` позволяет отменять асинхронные операции.
*   `AbortController` создает `AbortSignal`, который передается в асинхронную операцию.
*   Вызов `controller.abort()` отменяет операцию и генерирует `AbortError`.
*   Важно обрабатывать `AbortError` в блоке `catch`.
*   `AbortController` полезен для предотвращения утечек памяти и нежелательных побочных эффектов в асинхронных операциях, особенно в UI-приложениях.



## Интерактивный пример

<Sandpack
  template="vanilla"
  files={{
    "/index.html": `<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AbortController Пример</title>
  <link rel="stylesheet" href="/styles.css">
</head>
<body>
  <div class="container">
    <h1>AbortController - Контроль над асинхронностью</h1>
    <button id="fetchButton">Получить данные</button>
    <button id="cancelButton" disabled>Отменить запрос</button>
    <div id="dataContainer"></div>
    <input type="text" id="urlInput" placeholder="Введите URL (например, /data.json)">
  </div>
  <script src="/index.js"><\/script>
</body>
</html>`,
    "/styles.css": `body {
  font-family: sans-serif;
  background-color: #222;
  color: #eee;
  padding: 20px;
}

.container {
  max-width: 600px;
  margin: 0 auto;
}

button {
  padding: 10px 20px;
  margin-right: 10px;
  background-color: #444;
  color: #eee;
  border: none;
  cursor: pointer;
  border-radius: 5px;
}

button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

#dataContainer {
  margin-top: 20px;
  padding: 10px;
  border: 1px solid #555;
  border-radius: 5px;
  min-height: 50px;
}

input[type="text"] {
  padding: 10px;
  margin-top: 10px;
  width: 100%;
  box-sizing: border-box;
  background-color: #333;
  color: #eee;
  border: 1px solid #555;
  border-radius: 5px;
}
`,
    "/index.js": `// Получаем элементы DOM
const fetchButton = document.getElementById('fetchButton');
const cancelButton = document.getElementById('cancelButton');
const dataContainer = document.getElementById('dataContainer');
const urlInput = document.getElementById('urlInput');

let controller = null; // Объявляем controller вне функции, чтобы он был доступен глобально

// Функция для получения данных
async function fetchData(url) {
  controller = new AbortController(); // Создаем новый AbortController при каждом запросе
  const signal = controller.signal;

  try {
    const response = await fetch(url, { signal });
    if (!response.ok) {
      throw new Error(\`Ошибка HTTP: \${'response.status'}\`);
    }
    const data = await response.json();
    dataContainer.textContent = JSON.stringify(data, null, 2); // Выводим данные в контейнер
    cancelButton.disabled = true;
    fetchButton.disabled = false;
  } catch (error) {
    if (error.name === 'AbortError') {
      dataContainer.textContent = 'Запрос отменен пользователем.';
    } else {
      dataContainer.textContent = 'Произошла ошибка: ' + error;
    }
    cancelButton.disabled = true;
    fetchButton.disabled = false;
  } finally {
    controller = null; // Сбрасываем controller после завершения запроса
  }
}

// Обработчик клика на кнопку "Получить данные"
fetchButton.addEventListener('click', () => {
  const url = urlInput.value || '/data.json'; // Используем введенный URL или data.json по умолчанию
  dataContainer.textContent = 'Загрузка...';
  fetchButton.disabled = true;
  cancelButton.disabled = false;
  fetchData(url);
});

// Обработчик клика на кнопку "Отменить запрос"
cancelButton.addEventListener('click', () => {
  if (controller) {
    controller.abort(); // Отменяем запрос
  }
});

// Создаем фиктивный endpoint для примера
fetchMock.mock('/data.json', {
  status: 200,
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ message: 'Привет, мир!', timestamp: Date.now() })
});
`
  }}
  options={{
    showNavigator: false,
    showLineNumbers: true,
    editorHeight: 400
  }}
/>
