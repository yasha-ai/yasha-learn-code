## JavaScript: Microtasks vs Macrotasks. Погружение в асинхронность.


![Иллюстрация к уроку](/lessons/javascript-microtasks-macrotasks.png)
В JavaScript асинхронные операции играют ключевую роль. Чтобы понять, как JavaScript справляется с ними, важно разобраться в разнице между microtasks и macrotasks.

### Что такое Microtasks и Macrotasks?

JavaScript - однопоточный язык, но он умеет выполнять асинхронные операции.  Для этого существует механизм Event Loop (цикл событий), который управляет выполнением задач. Задачи делятся на два основных типа:

*   **Macrotasks (макрозадачи):** Это задачи, добавляемые в очередь задач (task queue). Примеры: `setTimeout`, `setInterval`, обработка событий (click, scroll), сетевые запросы (fetch, XMLHttpRequest).
*   **Microtasks (микрозадачи):** Это задачи, добавляемые в очередь микрозадач (microtask queue). Примеры: `Promise.then`, `MutationObserver`, `process.nextTick` (в Node.js).

Главное отличие в порядке выполнения: Event Loop сначала выполняет текущий macrotask, затем все доступные microtasks, и только потом переходит к следующему macrotask.

### Пример кода

```javascript
console.log("Начало");

setTimeout(() => {
  console.log("Macrotask: setTimeout");
}, 0);

Promise.resolve().then(() => {
  console.log("Microtask: Promise.then");
});

console.log("Конец");

// Вывод:
// Начало
// Конец
// Microtask: Promise.then
// Macrotask: setTimeout
```

В этом примере сначала выполняются синхронные операции ("Начало" и "Конец"). Затем, перед следующим macrotask, выполняются все microtasks, в данном случае `Promise.then`.  `setTimeout` добавляется в очередь macrotasks и выполняется позже.

### Еще один пример

```javascript
console.log("Начало");

setTimeout(() => {
  console.log("Macrotask 1");
  Promise.resolve().then(() => {
    console.log("Microtask внутри Macrotask 1");
  });
}, 0);

setTimeout(() => {
  console.log("Macrotask 2");
}, 0);

Promise.resolve().then(() => {
  console.log("Microtask 1");
  return Promise.resolve();
}).then(() => {
  console.log("Microtask 2");
});

console.log("Конец");

// Вывод:
// Начало
// Конец
// Microtask 1
// Microtask 2
// Macrotask 1
// Microtask внутри Macrotask 1
// Macrotask 2
```

Этот пример демонстрирует, что microtasks, созданные внутри macrotasks, выполняются после завершения текущего macrotask, но до начала следующего.

### Жизненный пример

В реальных веб-приложениях понимание разницы между microtasks и macrotasks важно для:

*   **Оптимизации производительности:**  Например, если у вас есть большое количество операций, которые нужно выполнить после обновления DOM, лучше использовать `Promise.then` (microtask), чтобы они выполнились сразу после обновления и не задерживали отрисовку следующего кадра.
*   **React:** React использует пакетные обновления. Изменения состояния (setState) часто планируются как microtasks, чтобы гарантировать, что все обновления состояния будут применены до того, как браузер перерисует DOM. Это помогает избежать ненужных перерисовок.
*   **Angular:** Angular использует Zone.js для отслеживания асинхронных операций. Zone.js также опирается на концепцию microtasks и macrotasks для управления жизненным циклом компонентов и обнаружения изменений.
*   **Vue.js:** Vue.js также использует microtasks для асинхронного обновления DOM.

### Ключевые моменты

*   Macrotasks (setTimeout, setInterval, обработчики событий, сетевые запросы) добавляются в очередь задач (task queue).
*   Microtasks (Promise.then, MutationObserver) добавляются в очередь микрозадач (microtask queue).
*   Event Loop сначала выполняет текущий macrotask.
*   Затем Event Loop выполняет все microtasks, накопившиеся в очереди.
*   Только после этого Event Loop переходит к следующему macrotask.
*   Знание разницы между microtasks и macrotasks помогает оптимизировать производительность и понимать, как работают популярные JavaScript фреймворки.



## Интерактивный пример

<Sandpack
  template="vanilla"
  files={{
    "/index.html": `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Microtasks vs Macrotasks</title>
  <link rel="stylesheet" href="/styles.css">
</head>
<body>
  <h1>Microtasks vs Macrotasks</h1>
  <p>Нажми на кнопку, чтобы увидеть порядок выполнения задач!</p>
  <button id="myButton">Запустить пример</button>
  <div id="output">
    <p>Консоль:</p>
    <pre id="consoleOutput"></pre>
  </div>
  <script src="/index.js"><\/script>
</body>
</html>`,
    "/styles.css": `body {
  font-family: sans-serif;
  background-color: #222;
  color: #eee;
  padding: 20px;
}

#output {
  margin-top: 20px;
  border: 1px solid #555;
  padding: 10px;
  background-color: #333;
  color: #fff;
}

#consoleOutput {
  white-space: pre-wrap;
  word-wrap: break-word;
}

button {
  background-color: #4CAF50; /* Green */
  border: none;
  color: white;
  padding: 15px 32px;
  text-align: center;
  text-decoration: none;
  display: inline-block;
  font-size: 16px;
  cursor: pointer;
  border-radius: 5px;
}
`,
    "/index.js": `const button = document.getElementById('myButton');
const consoleOutput = document.getElementById('consoleOutput');

function logToConsole(message) {
  consoleOutput.textContent += message + '\\n';
}

button.addEventListener('click', () => {
  consoleOutput.textContent = ''; // Очищаем консоль перед каждым запуском

  logToConsole("Начало");

  setTimeout(() => {
    logToConsole("Macrotask: setTimeout 1");
    Promise.resolve().then(() => {
      logToConsole("Microtask внутри Macrotask: Promise.then");
    });
  }, 0);

  setTimeout(() => {
    logToConsole("Macrotask: setTimeout 2");
  }, 0);

  Promise.resolve().then(() => {
    logToConsole("Microtask: Promise.then 1");
    return Promise.resolve();
  }).then(() => {
    logToConsole("Microtask: Promise.then 2");
  });

  logToConsole("Конец");
});
`
  }}
  options={{
    showNavigator: false,
    showLineNumbers: true,
    editorHeight: 400
  }}
/>
