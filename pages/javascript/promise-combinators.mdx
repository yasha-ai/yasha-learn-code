## JavaScript: Мозги. Урок: Promise Combinators


![Иллюстрация к уроку](/lessons/javascript-promise-combinators.png)
Promise Combinators – это мощные инструменты JavaScript, позволяющие эффективно управлять несколькими промисами одновременно. Они значительно упрощают асинхронный код, делая его более читаемым и поддерживаемым.

### Что такое Promise Combinators?

Promise Combinators – это статические методы класса `Promise`, которые принимают массив промисов и возвращают один промис, представляющий результат обработки этого массива.  Они позволяют выполнять операции над множеством асинхронных задач параллельно или последовательно, в зависимости от выбранного комбинатора.

#### Основные комбинаторы:

*   **`Promise.all(promises)`**: Возвращает промис, который разрешается, когда *все* промисы из массива `promises` успешно разрешились. В случае, если хотя бы один промис отклоняется, возвращаемый промис также отклоняется с причиной отклонения этого промиса.

    ```javascript
    const promise1 = Promise.resolve(1);
    const promise2 = new Promise((resolve) => setTimeout(() => resolve(2), 100));
    const promise3 = Promise.resolve(3);

    Promise.all([promise1, promise2, promise3])
      .then((values) => {
        console.log(values); // [1, 2, 3]
      })
      .catch((error) => {
        console.error(error);
      });
    ```

*   **`Promise.allSettled(promises)`**: Возвращает промис, который разрешается, когда *все* промисы из массива `promises` либо разрешились, либо отклонились. Результатом является массив объектов, каждый из которых описывает статус соответствующего промиса (`status: 'fulfilled'` или `status: 'rejected'`) и его значение (`value`) или причину отклонения (`reason`).

    ```javascript
    const promise1 = Promise.resolve(1);
    const promise2 = Promise.reject('Ошибка!');
    const promise3 = new Promise((resolve) => setTimeout(() => resolve(3), 100));

    Promise.allSettled([promise1, promise2, promise3])
      .then((results) => {
        console.log(results);
        // [
        //   { status: 'fulfilled', value: 1 },
        //   { status: 'rejected', reason: 'Ошибка!' },
        //   { status: 'fulfilled', value: 3 }
        // ]
      });
    ```

*   **`Promise.race(promises)`**: Возвращает промис, который разрешается или отклоняется в зависимости от того, какой из промисов в массиве `promises` разрешится или отклонится *первым*.

    ```javascript
    const promise1 = new Promise((resolve) => setTimeout(() => resolve(1), 500));
    const promise2 = new Promise((resolve) => setTimeout(() => resolve(2), 100));

    Promise.race([promise1, promise2])
      .then((value) => {
        console.log(value); // 2 (потому что promise2 разрешился первым)
      });
    ```

*   **`Promise.any(promises)`**: Возвращает промис, который разрешается, как только *один* из промисов в массиве `promises` успешно разрешится. Если все промисы отклоняются, возвращаемый промис отклоняется с ошибкой `AggregateError`, содержащей причины отклонения всех промисов.

    ```javascript
    const promise1 = Promise.reject('Ошибка 1');
    const promise2 = new Promise((resolve, reject) => setTimeout(() => reject('Ошибка 2'), 100));
    const promise3 = Promise.resolve(3);

    Promise.any([promise1, promise2, promise3])
      .then((value) => {
        console.log(value); // 3 (потому что promise3 разрешился)
      })
      .catch((error) => {
          console.log(error);
      });
    ```

### Жизненный пример

Представьте себе, что вам нужно загрузить данные с нескольких API и отобразить их на странице.

```javascript
async function fetchData() {
  const urls = [
    '/api/users',
    '/api/posts',
    '/api/comments'
  ];

  try {
    const responses = await Promise.all(urls.map(url => fetch(url).then(res => res.json())));
    const users = responses[0];
    const posts = responses[1];
    const comments = responses[2];

    // Отображение данных на странице...
    console.log('Данные загружены:', { users, posts, comments });

  } catch (error) {
    console.error('Ошибка при загрузке данных:', error);
  }
}

fetchData();
```

В этом примере `Promise.all` гарантирует, что все запросы к API будут выполнены параллельно, и только после этого данные будут обработаны и отображены. Если хотя бы один запрос завершится неудачей, вся операция будет прервана, и будет выведено сообщение об ошибке.  Такой подход часто применяется в веб-разработке для одновременной загрузки нескольких ресурсов, что значительно ускоряет загрузку страницы. Фреймворки и библиотеки, такие как React, Angular и Vue.js, активно используют Promise Combinators для управления асинхронными операциями, такими как запросы к серверу и обновление пользовательского интерфейса.

### Ключевые моменты

*   Promise Combinators позволяют управлять несколькими промисами одновременно.
*   `Promise.all` ожидает разрешения всех промисов.
*   `Promise.allSettled` ожидает завершения всех промисов (независимо от статуса).
*   `Promise.race` разрешается или отклоняется в зависимости от первого разрешенного или отклоненного промиса.
*   `Promise.any` разрешается при первом успешно разрешенном промисе.
*   Использование Promise Combinators делает асинхронный код более читаемым и управляемым.



## Интерактивный пример

<Sandpack
  template="vanilla"
  files={{
    "/index.html": `<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Promise Combinators Demo</title>
  <link rel="stylesheet" href="/styles.css">
</head>
<body>
  <div class="container">
    <h1>Promise Combinators Demo</h1>

    <div class="button-container">
      <button id="allButton">Promise.all</button>
      <button id="allSettledButton">Promise.allSettled</button>
      <button id="raceButton">Promise.race</button>
      <button id="anyButton">Promise.any</button>
    </div>

    <div id="output">
      <!-- Здесь будет отображаться результат -->
    </div>
  </div>

  <script src="/index.js"><\/script>
</body>
</html>`,
    "/styles.css": `body {
  font-family: sans-serif;
  background-color: #222;
  color: #eee;
  padding: 20px;
}

.container {
  max-width: 800px;
  margin: 0 auto;
}

.button-container {
  display: flex;
  gap: 10px;
  margin-bottom: 20px;
}

button {
  background-color: #444;
  color: #eee;
  border: none;
  padding: 10px 20px;
  cursor: pointer;
  border-radius: 5px;
}

button:hover {
  background-color: #555;
}

#output {
  border: 1px solid #444;
  padding: 10px;
  margin-top: 20px;
  background-color: #333;
  border-radius: 5px;
  min-height: 100px;
}
`,
    "/index.js": `// Функция для создания промиса с задержкой
function createPromise(value, delay, shouldReject = false) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (shouldReject) {
        reject(\`Промис отклонен со значением: \${'}value'}\`);
      } else {
        resolve(value);
      }
    }, delay);
  });
}

// Получаем элементы DOM
const allButton = document.getElementById('allButton');
const allSettledButton = document.getElementById('allSettledButton');
const raceButton = document.getElementById('raceButton');
const anyButton = document.getElementById('anyButton');
const outputDiv = document.getElementById('output');

// Обработчик для Promise.all
allButton.addEventListener('click', () => {
  outputDiv.textContent = 'Загрузка...';
  const promise1 = createPromise(1, 200);
  const promise2 = createPromise(2, 100);
  const promise3 = createPromise(3, 300);

  Promise.all([promise1, promise2, promise3])
    .then((values) => {
      outputDiv.textContent = \`Promise.all: \${'}JSON.stringify(values)'}\`;
    })
    .catch((error) => {
      outputDiv.textContent = \`Promise.all: Ошибка - \${'}error'}\`;
    });
});

// Обработчик для Promise.allSettled
allSettledButton.addEventListener('click', () => {
  outputDiv.textContent = 'Загрузка...';
  const promise1 = createPromise(1, 200);
  const promise2 = createPromise(2, 100, true); // Отклоняющийся промис
  const promise3 = createPromise(3, 300);

  Promise.allSettled([promise1, promise2, promise3])
    .then((results) => {
      outputDiv.textContent = \`Promise.allSettled: \${'}JSON.stringify(results, null, 2)'}\`;
    });
});

// Обработчик для Promise.race
raceButton.addEventListener('click', () => {
  outputDiv.textContent = 'Загрузка...';
  const promise1 = createPromise(1, 300);
  const promise2 = createPromise(2, 100);

  Promise.race([promise1, promise2])
    .then((value) => {
      outputDiv.textContent = \`Promise.race: \${'}value'}\`;
    })
    .catch((error) => {
      outputDiv.textContent = \`Promise.race: Ошибка - \${'}error'}\`;
    });
});

// Обработчик для Promise.any
anyButton.addEventListener('click', () => {
  outputDiv.textContent = 'Загрузка...';
  const promise1 = createPromise(1, 300, true); // Отклоняющийся промис
  const promise2 = createPromise(2, 100, true); // Отклоняющийся промис
  const promise3 = createPromise(3, 200);

  Promise.any([promise1, promise2, promise3])
    .then((value) => {
      outputDiv.textContent = \`Promise.any: \${'}value'}\`;
    })
    .catch((error) => {
      outputDiv.textContent = \`Promise.any: Ошибка - \${'}error'}.  (Все промисы отклонены)\`;
    });
});
`
  }}
  options={{
    showNavigator: false,
    showLineNumbers: true,
    editorHeight: 400
  }}
/>
