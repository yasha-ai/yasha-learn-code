import { Sandpack } from '@codesandbox/sandpack-react'

# Symbol

Symbol — уникальный примитивный тип данных в JavaScript. Каждый Symbol гарантированно уникален, даже если создан с одинаковым описанием. Используется для создания скрытых свойств объектов и реализации специального поведения через well-known symbols.

## Создание символов

```javascript
const sym1 = Symbol()
const sym2 = Symbol('описание')
const sym3 = Symbol('описание')

console.log(sym1 === sym2)   // false — каждый Symbol уникален
console.log(sym2 === sym3)   // false — даже с одинаковым описанием!
console.log(typeof sym1)     // 'symbol'
console.log(sym2.toString()) // 'Symbol(описание)'
console.log(sym2.description) // 'описание'
```

## Символы как ключи объектов

Главное применение Symbol — создание «скрытых» свойств, которые не попадают в обычные итерации:

```javascript
const id = Symbol('id')
const name = Symbol('name')

const user = {
  [id]: 123,
  [name]: 'Алексей',
  login: 'alexei',
}

// Обычная итерация не показывает Symbol-свойства
console.log(Object.keys(user))         // ['login']
console.log(JSON.stringify(user))       // '{"login":"alexei"}'

// Получить Symbol-свойства можно явно
console.log(user[id])                  // 123
console.log(Object.getOwnPropertySymbols(user)) // [Symbol(id), Symbol(name)]
```

## Symbol.for — глобальный реестр

`Symbol.for(key)` создаёт символ в глобальном реестре. Одинаковый ключ — один и тот же символ, даже из разных модулей:

```javascript
const s1 = Symbol.for('shared')
const s2 = Symbol.for('shared')

console.log(s1 === s2)       // true — один символ из реестра!
console.log(Symbol.keyFor(s1)) // 'shared'

// Обычный Symbol не попадает в реестр
const local = Symbol('local')
console.log(Symbol.keyFor(local)) // undefined
```

## Well-known символы

JavaScript использует встроенные символы для настройки поведения объектов.

### Symbol.iterator

Позволяет сделать объект итерируемым:

```javascript
const range = {
  from: 1,
  to: 5,
  [Symbol.iterator]() {
    let current = this.from
    const last = this.to
    return {
      next() {
        return current <= last
          ? { value: current++, done: false }
          : { value: undefined, done: true }
      }
    }
  }
}

for (const num of range) {
  console.log(num) // 1, 2, 3, 4, 5
}

console.log([...range]) // [1, 2, 3, 4, 5]
```

### Symbol.toPrimitive

Управляет приведением объекта к примитиву:

```javascript
const money = {
  amount: 100,
  currency: 'USD',
  [Symbol.toPrimitive](hint) {
    if (hint === 'number') return this.amount
    if (hint === 'string') return `${this.amount} ${this.currency}`
    return this.amount // 'default'
  }
}

console.log(+money)         // 100 (number hint)
console.log(`${money}`)     // '100 USD' (string hint)
console.log(money + 50)     // 150 (default hint)
```

### Symbol.hasInstance

Настраивает оператор `instanceof`:

```javascript
class EvenNumber {
  static [Symbol.hasInstance](num) {
    return Number.isInteger(num) && num % 2 === 0
  }
}

console.log(2 instanceof EvenNumber)  // true
console.log(3 instanceof EvenNumber)  // false
console.log(4 instanceof EvenNumber)  // true
```

### Другие well-known символы

| Символ | Назначение |
|--------|-----------|
| `Symbol.iterator` | Итерируемость (`for...of`, spread) |
| `Symbol.asyncIterator` | Асинхронная итерация |
| `Symbol.toPrimitive` | Приведение к примитиву |
| `Symbol.toStringTag` | Результат `Object.prototype.toString` |
| `Symbol.hasInstance` | Поведение `instanceof` |
| `Symbol.species` | Конструктор для создания производных объектов |

## Практический пример: приватные поля через Symbol

```javascript
// Паттерн "скрытые свойства" через Symbol
const _balance = Symbol('balance')
const _owner = Symbol('owner')

class BankAccount {
  constructor(owner, initialBalance) {
    this[_owner] = owner
    this[_balance] = initialBalance
  }

  deposit(amount) {
    if (amount <= 0) throw new Error('Сумма должна быть положительной')
    this[_balance] += amount
    return this
  }

  withdraw(amount) {
    if (amount > this[_balance]) throw new Error('Недостаточно средств')
    this[_balance] -= amount
    return this
  }

  toString() {
    return `Счёт ${this[_owner]}: ${this[_balance]} руб.`
  }
}

const account = new BankAccount('Алексей', 1000)
account.deposit(500).withdraw(200)
console.log(account.toString()) // 'Счёт Алексей: 1300 руб.'

// Свойство "скрыто" от обычного доступа
console.log(Object.keys(account))  // []
console.log(account.balance)       // undefined
```

## Задания для практики

1. Создайте Symbol `SECRET_KEY` и используйте его как ключ в объекте конфигурации.
2. Реализуйте итерируемый класс `Fibonacci`, генерирующий числа Фибоначчи через `Symbol.iterator`.
3. Добавьте `Symbol.toPrimitive` к классу `Temperature` для конвертации в Celsius/Fahrenheit.
4. Используйте `Symbol.for('validator')` для создания общего символа валидации между модулями.

## Интерактивный пример

<Sandpack
  template="vanilla"
  files={{
    "/index.html": `<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>Symbol</title>
  <link rel="stylesheet" href="/styles.css">
</head>
<body>
  <h2>Symbol в JavaScript</h2>
  <div id="output"></div>
  <script src="/index.js"></script>
</body>
</html>`,
    "/styles.css": `body { font-family: sans-serif; background: #1e1e2e; color: #cdd6f4; padding: 20px; }
h2 { color: #89b4fa; }
.result { background: #313244; border-radius: 6px; padding: 12px; margin: 8px 0; font-family: monospace; font-size: 14px; }
.label { color: #a6e3a1; font-weight: bold; margin-right: 8px; }`,
    "/index.js": `// Демонстрация Symbol
const output = document.getElementById('output')
function log(label, value) {
  const div = document.createElement('div')
  div.className = 'result'
  div.innerHTML = \`<span class="label">\${label}:</span>\${String(value)}\`
  output.appendChild(div)
}

// Уникальность
const a = Symbol('test')
const b = Symbol('test')
log('Symbol("test") === Symbol("test")', a === b)

// Symbol как ключ
const id = Symbol('id')
const user = { [id]: 42, name: 'Яша' }
log('user[id]', user[id])
log('Object.keys(user)', JSON.stringify(Object.keys(user)))

// Symbol.for — глобальный реестр
const s1 = Symbol.for('global')
const s2 = Symbol.for('global')
log('Symbol.for("global") ===', s1 === s2)

// Symbol.iterator — кастомная итерация
const range = {
  from: 1, to: 4,
  [Symbol.iterator]() {
    let n = this.from
    const end = this.to
    return { next: () => n <= end ? { value: n++, done: false } : { done: true } }
  }
}
log('[...range]', JSON.stringify([...range]))
`
  }}
  options={{ showNavigator: false, showLineNumbers: true, editorHeight: 380 }}
/>
